
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>2.2.5 优先队列</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>04_2.2.5_优先队列</h1>
<pre><code>Lecture: 02._排序和顺序统计/2.2_堆排序
Content: 04_2.2.5_优先队列
</code></pre>
<h3>2.2.5 优先队列（Priority Queues）</h3>
<p>优先队列是一种特殊的队列数据结构，其中每个元素都具有一个优先级，并且每次访问时，总是优先级最高的元素最先被处理。优先队列在计算机科学中的许多应用场景中都有广泛的使用，例如任务调度、路径查找和事件驱动模拟。本文将详细分析优先队列的结构、操作及其实现细节。</p>
<h4>优先队列的基本概念</h4>
<p>优先队列通常有两种形式：最大优先队列（max-priority queue）和最小优先队列（min-priority queue）。在最大优先队列中，每次删除操作返回优先级最高的元素；在最小优先队列中，每次删除操作返回优先级最低的元素。优先队列可以通过堆（heap）数据结构高效地实现。</p>
<h4>最大优先队列的基本操作</h4>
<p>最大优先队列支持以下基本操作：</p>
<ol>
<li><strong>INSERT(S, x, k)</strong>：将元素<code>x</code>及其键值<code>k</code>插入集合<code>S</code>中。</li>
<li><strong>MAXIMUM(S)</strong>：返回集合<code>S</code>中具有最大键值的元素。</li>
<li><strong>EXTRACT-MAX(S)</strong>：移除并返回集合<code>S</code>中具有最大键值的元素。</li>
<li><strong>INCREASE-KEY(S, x, k)</strong>：将元素<code>x</code>的键值增加到新的值<code>k</code>，假设新的键值<code>k</code>不小于<code>x</code>当前的键值。</li>
</ol>
<h4>最大优先队列的实现</h4>
<p>最大优先队列通常基于最大堆（max-heap）实现。最大堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值。以下是基于最大堆实现最大优先队列的详细步骤：</p>
<ol>
<li>
<p><strong>INSERT(S, x, k)</strong>：</p>
<ul>
<li>将新元素<code>x</code>添加到堆的末尾。</li>
<li>将新元素的键值设为负无穷大。</li>
<li>调用<code>INCREASE-KEY</code>将新元素的键值增加到<code>k</code>，并调整堆以维持最大堆性质。</li>
</ul>
</li>
<li>
<p><strong>MAXIMUM(S)</strong>：</p>
<ul>
<li>直接返回堆顶元素，时间复杂度为<code>O(1)</code>。</li>
</ul>
</li>
<li>
<p><strong>EXTRACT-MAX(S)</strong>：</p>
<ul>
<li>返回并移除堆顶元素（最大元素）。</li>
<li>将堆的最后一个元素移动到堆顶，然后调用<code>MAX-HEAPIFY</code>恢复堆的最大堆性质。时间复杂度为<code>O(log n)</code>，其中<code>n</code>是堆中元素的数量。</li>
</ul>
</li>
<li>
<p><strong>INCREASE-KEY(S, x, k)</strong>：</p>
<ul>
<li>首先检查新的键值是否大于当前键值。</li>
<li>更新元素<code>x</code>的键值为<code>k</code>。</li>
<li>通过向上调整的方法恢复最大堆性质，时间复杂度为<code>O(log n)</code>。</li>
</ul>
</li>
</ol>
<h4>优先队列的应用</h4>
<p>优先队列在实际应用中有许多重要用途。例如：</p>
<ol>
<li><strong>任务调度</strong>：计算机操作系统中的任务调度使用最大优先队列来管理等待执行的任务，优先级最高的任务将最先执行。</li>
<li><strong>路径查找</strong>：在Dijkstra算法和A*算法中，最小优先队列用于选取当前最短路径或最优路径。</li>
<li><strong>事件驱动模拟</strong>：在离散事件模拟中，最小优先队列用于按时间顺序处理事件，每次处理最早发生的事件。</li>
</ol>
<h4>优先队列的复杂度分析</h4>
<p>基于最大堆实现的优先队列各操作的时间复杂度如下：</p>
<ul>
<li><strong>INSERT</strong>：O(log n)</li>
<li><strong>MAXIMUM</strong>：O(1)</li>
<li><strong>EXTRACT-MAX</strong>：O(log n)</li>
<li><strong>INCREASE-KEY</strong>：O(log n)</li>
</ul>
<p>这些操作的高效性使得基于堆实现的优先队列在处理大量数据时表现优异。</p>
<h4>进一步扩展</h4>
<p>除了基于二叉堆的优先队列，还有其他复杂度更优的实现，如Fibonacci堆。Fibonacci堆支持更快的插入和键值减小操作，但实现较为复杂，常用于高级算法和特定应用中。</p>
<h4>总结</h4>
<p>优先队列是计算机科学中广泛使用的高级数据结构，基于堆实现的优先队列在时间复杂度和空间复杂度上都表现出色。通过深入理解优先队列的操作及其实现，可以有效提升解决复杂问题的能力。</p>

    <h3>Python 文件</h3>
    <pre><code># 04_2.2.5_优先队列

"""
Lecture: 02._排序和顺序统计/2.2_堆排序
Content: 04_2.2.5_优先队列
"""

import numpy as np
from typing import List, Tuple

class PriorityQueue:
    def __init__(self):
        """
        初始化优先队列，使用一个空的numpy数组来存储元素。
        """
        self.heap = np.array([], dtype=int)
        self.heap_size = 0
    
    def parent(self, i: int) -> int:
        """
        获取父节点的索引
        
        Args:
            i (int): 当前节点的索引
            
        Returns:
            int: 父节点的索引
        """
        return (i - 1) // 2
    
    def left(self, i: int) -> int:
        """
        获取左子节点的索引
        
        Args:
            i (int): 当前节点的索引
            
        Returns:
            int: 左子节点的索引
        """
        return 2 * i + 1
    
    def right(self, i: int) -> int:
        """
        获取右子节点的索引
        
        Args:
            i (int): 当前节点的索引
            
        Returns:
            int: 右子节点的索引
        """
        return 2 * i + 2
    
    def max_heapify(self, i: int):
        """
        维护最大堆性质
        
        Args:
            i (int): 当前节点的索引
        """
        l = self.left(i)
        r = self.right(i)
        largest = i
        
        if l < self.heap_size and self.heap[l] > self.heap[largest]:
            largest = l
        if r < self.heap_size and self.heap[r] > self.heap[largest]:
            largest = r
        if largest != i:
            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]
            self.max_heapify(largest)
    
    def build_max_heap(self):
        """
        构建最大堆
        """
        self.heap_size = len(self.heap)
        for i in range(len(self.heap) // 2 - 1, -1, -1):
            self.max_heapify(i)
    
    def insert(self, key: int):
        """
        插入一个新元素到优先队列中
        
        Args:
            key (int): 要插入的元素
        """
        self.heap = np.append(self.heap, -np.inf)
        self.heap_size += 1
        self.increase_key(self.heap_size - 1, key)
    
    def maximum(self) -> int:
        """
        获取最大元素（优先级最高的元素）
        
        Returns:
            int: 最大元素
        """
        if self.heap_size < 1:
            raise IndexError("Heap underflow")
        return self.heap[0]
    
    def extract_max(self) -> int:
        """
        提取并返回最大元素
        
        Returns:
            int: 最大元素
        """
        if self.heap_size < 1:
            raise IndexError("Heap underflow")
        max_elem = self.heap[0]
        self.heap[0] = self.heap[self.heap_size - 1]
        self.heap_size -= 1
        self.heap = np.delete(self.heap, self.heap_size)
        self.max_heapify(0)
        return max_elem
    
    def increase_key(self, i: int, key: int):
        """
        增加索引i处元素的键值到key
        
        Args:
            i (int): 元素的索引
            key (int): 新的键值
        """
        if key < self.heap[i]:
            raise ValueError("New key is smaller than current key")
        self.heap[i] = key
        while i > 0 and self.heap[self.parent(i)] < self.heap[i]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)

def main():
    # 工业场景下使用优先队列
    pq = PriorityQueue()
    
    # 插入一些元素
    data = [15, 3, 17, 10, 84, 19, 6, 22, 9]
    for item in data:
        pq.insert(item)
    
    print("最大堆:", pq.heap.tolist())
    
    # 获取最大元素
    print("最大元素:", pq.maximum())
    
    # 提取最大元素
    print("提取最大元素:", pq.extract_max())
    print("提取后最大堆:", pq.heap.tolist())
    
    # 增加键值
    pq.increase_key(4, 50)
    print("增加键值后最大堆:", pq.heap.tolist())

if __name__ == "__main__":
    main()
</code></pre>
  </div>
</body>
</html>
  