# 03_2.3.4_快速排序分析

"""
Lecture: 02._排序和顺序统计/2.3_快速排序
Content: 03_2.3.4_快速排序分析
"""

### 2.3.4 快速排序分析

快速排序（Quicksort）是一种高效的排序算法，广泛应用于实际中。为了更深入地理解其性能，我们需要分析其在最坏、最好和平均情况下的时间复杂度，以及随机化版本的优势和实际表现。

#### 最坏情况分析

在最坏情况下，快速排序的时间复杂度为 $O(n^2)$。这种情况发生在每次分区时，基准元素总是选择了子数组的最小或最大元素，使得每次分区都极不平衡。例如，当输入数组已经有序或逆序时，会出现这种情况。

**最坏情况分析**：
- 每次分区的时间复杂度为 $O(n)$，因为需要遍历整个子数组来找到基准元素的位置。
- 由于每次分区后的一个子数组为空，另一个子数组包含 $n-1$ 个元素，因此递归调用的深度为 $n$。
- 总时间复杂度为 $T(n) = T(n-1) + O(n) = O(n^2)$。

#### 最好情况分析

在最好情况下，每次分区的结果是两个大小大致相等的子数组，这样快速排序的递归树深度为 $\log n$，每层的工作量为 $O(n)$，总时间复杂度为 $O(n \log n)$。

**最好情况分析**：
- 每次分区的时间复杂度仍然是 $O(n)$。
- 分区后的两个子数组大小为 $\lfloor n/2 \rfloor$ 和 $\lceil n/2 \rceil$，递归树的深度为 $\log n$。
- 总时间复杂度为 $T(n) = 2T(n/2) + O(n)$，根据主定理，解决该递归式得到 $T(n) = O(n \log n)$。

#### 平均情况分析

平均情况下，快速排序的性能也接近于 $O(n \log n)$。在随机排列的输入数组上，快速排序的分区结果大部分情况下都是相对平衡的。

**平均情况分析**：
- 假设每次分区基准元素将数组大致均匀地分成两个部分，则递归树的深度为 $\log n$。
- 每层的总工作量为 $O(n)$，因为每个元素在每层只被比较一次。
- 总时间复杂度为 $T(n) = 2T(n/2) + O(n)$，根据主定理，得到 $T(n) = O(n \log n)$。

#### 分区的影响

快速排序的关键在于分区操作（partitioning）。分区的平衡性直接影响算法的性能。以下是不同分区平衡性对性能的影响：
- **极不平衡分区**：每次分区产生一个非常小的子数组和一个几乎与原数组一样大的子数组。这种情况下，递归深度接近 $n$，总时间复杂度为 $O(n^2)$。
- **均衡分区**：每次分区产生两个大小大致相等的子数组。这种情况下，递归深度为 $\log n$，总时间复杂度为 $O(n \log n)$。
- **常数比例分区**：每次分区产生的子数组按固定比例（例如9:1）分割，即使看似不平衡，递归深度仍为 $\log n$，总时间复杂度仍为 $O(n \log n)$。

#### 随机化快速排序分析

为了避免最坏情况的发生，可以引入随机化策略，即随机选择基准元素。随机化快速排序在大多数情况下能够保证 $O(n \log n)$ 的期望时间复杂度。

**随机化的优势**：
- **避免最坏情况**：随机选择基准元素，可以避免输入数据的某种特殊顺序导致最坏情况。
- **期望性能稳定**：随机化策略使得在所有输入上的期望时间复杂度为 $O(n \log n)$。

**随机化快速排序的期望时间复杂度**：
- 在每一层递归中，随机选择基准元素使得分区相对均匀，因此递归树的深度为 $\log n$。
- 每层的工作量为 $O(n)$，因此期望时间复杂度为 $O(n \log n)$。

#### 实际应用

快速排序在实际应用中表现优异，尤其适用于大规模数据的排序。其原地排序特性使其在空间有限的情况下优势明显。然而，为避免最坏情况的发生，常采用随机选择基准元素或三点取中法等改进措施。

### 总结

快速排序是一种高效的排序算法，其性能在很大程度上取决于分区的平衡性。虽然在最坏情况下时间复杂度为 $O(n^2)$，但在随机输入情况下，其平均时间复杂度为 $O(n \log n)$，适用于大多数实际应用场景。通过引入随机化策略，可以进一步提高快速排序的稳定性和性能。
