# 01_2.5.2_预期线性时间选择

"""
Lecture: 02._排序和顺序统计/2.5_中位数和顺序统计
Content: 01_2.5.2_预期线性时间选择
"""

### 2.5.2 预期线性时间选择

在《算法导论》第2.5.2节中，讨论了一种称为“随机选择”的算法，该算法能够在预期线性时间内找到数组中的第 $ i $ 小的元素。该算法的灵感来源于快速排序，利用随机化技术来优化算法的期望时间复杂度。

#### 算法描述

随机选择算法的主要思想是通过随机选择一个枢轴元素，将数组分成两部分，并递归地在适当的一部分中继续查找。与快速排序不同的是，随机选择算法只处理划分的一侧，这使得它的期望运行时间为线性时间。

#### 步骤

1. **随机化划分**：
   - 使用 `RANDOMIZED-PARTITION` 函数对数组进行划分，随机选择一个枢轴元素并将数组分为两部分，使得左侧部分的元素都小于等于枢轴元素，右侧部分的元素都大于枢轴元素。

2. **递归选择**：
   - 根据枢轴元素的位置确定下一步操作：
     - 如果枢轴元素的位置正好是第 $ i $ 小的元素，直接返回该元素。
     - 如果第 $ i $ 小的元素在左侧部分，递归地在左侧部分查找。
     - 如果第 $ i $ 小的元素在右侧部分，递归地在右侧部分查找。

#### 伪代码

以下是 `RANDOMIZED-SELECT` 算法的伪代码：
```
RANDOMIZED-SELECT(A, p, r, i)
1 if p == r
2     return A[p]
3 q = RANDOMIZED-PARTITION(A, p, r)
4 k = q - p + 1
5 if i == k
6     return A[q]
7 elseif i < k
8     return RANDOMIZED-SELECT(A, p, q - 1, i)
9 else
10    return RANDOMIZED-SELECT(A, q + 1, r, i - k)
```

#### 算法分析

随机选择算法的时间复杂度可以通过以下几个方面进行分析：

1. **随机化划分**：
   - 划分操作的期望时间为线性时间 $ O(n) $。

2. **递归操作**：
   - 每次递归调用处理的子数组长度约为原数组长度的一半，因此递归调用的期望次数为 $ O(\log n) $。

3. **总体期望时间复杂度**：
   - 由于每次递归调用的时间复杂度为 $ O(n) $，而递归调用的期望次数为 $ O(\log n) $，因此总体期望时间复杂度为 $ O(n) $。

#### 示例

假设有一个数组 `A = [3, 2, 9, 7, 6, 4, 5, 1, 8]`，我们希望找到第4小的元素。使用随机选择算法的具体步骤如下：

1. **第一次划分**：
   - 随机选择一个枢轴元素，例如选择 `6`，划分后数组变为 `[3, 2, 1, 4, 5, 6, 9, 7, 8]`，枢轴位置为6，枢轴值为`6`。

2. **递归选择**：
   - 由于第4小的元素在枢轴位置的左侧，继续在 `[3, 2, 1, 4, 5]` 中查找。

3. **第二次划分**：
   - 在子数组中再次随机选择枢轴元素，例如选择 `4`，划分后子数组变为 `[3, 2, 1, 4, 5]`，枢轴位置为4，枢轴值为`4`。

4. **递归选择**：
   - 由于第4小的元素正好是枢轴元素 `4`，返回该元素。

#### 结论

第2.5.2节详细介绍了随机选择算法，通过利用随机化技术，能够在预期线性时间内找到数组中的第 $ i $ 小的元素。该算法的主要优势在于其简单性和高效性，特别适用于处理大规模数据集。理解和掌握该算法，对于优化查找问题和提高程序性能具有重要意义。
