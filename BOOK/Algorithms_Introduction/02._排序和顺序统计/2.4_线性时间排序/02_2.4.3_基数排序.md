# 02_2.4.3_基数排序

"""
Lecture: 02._排序和顺序统计/2.4_线性时间排序
Content: 02_2.4.3_基数排序
"""

### 2.4.3 基数排序

基数排序（Radix Sort）是一种线性时间复杂度的排序算法，适用于处理大量具有多个关键字的整数数据。基数排序的基本思想是通过对数据的每一位（或每一部分）进行排序，从而达到整体有序的效果。该部分详细介绍了基数排序的工作原理、实现步骤和性能分析。

#### 基本思想

基数排序通过对每个数字的每一位（从最低有效位到最高有效位，或从最高有效位到最低有效位）进行排序来实现整体排序。关键步骤包括：

1. **位排序**：选择排序的位（或部分），通常从最低有效位开始。
2. **稳定排序**：对选定的位（或部分）进行稳定排序，确保相同位（或部分）内的相对顺序不变。
3. **重复步骤**：依次对更高位（或部分）进行稳定排序，直到所有位（或部分）排序完成。

#### 详细步骤

1. **初始化**：
   - 假设有 $ n $ 个 $ d $ 位数字，每个位可以取 $ k $ 个不同的值。
   - 初始化两个数组：输入数组 `A` 和输出数组 `B`。

2. **位排序循环**：
   - 从最低有效位（或部分）开始，对每一位（或部分）进行排序。
   - 使用计数排序（Counting Sort）等稳定排序算法对当前位（或部分）进行排序。

3. **稳定排序**：
   - 使用计数排序对每个位（或部分）进行排序时，确保相同位（或部分）内的相对顺序不变。
   - 在每次排序后，将排序结果存储到输出数组 `B`，然后交换 `A` 和 `B` 的角色，以便进行下一位（或部分）的排序。

#### 伪代码
```
RADIX-SORT(A, d)
1 for i = 1 to d
2     使用稳定排序算法对数组 A 的第 i 位进行排序
```

#### 时间复杂度分析

基数排序的时间复杂度为 $ O(d \cdot (n + k)) $，其中 $ n $ 是输入数组的大小，$ d $ 是数字的位数，$ k $ 是每个位的取值范围。

1. **计数排序时间复杂度**：
   - 对每一位使用计数排序进行排序，时间复杂度为 $ O(n + k) $。

2. **总时间复杂度**：
   - 由于基数排序对每个位都要进行一次计数排序，总时间复杂度为 $ O(d \cdot (n + k)) $。

在实际应用中，当 $ d $ 和 $ k $ 都较小时，基数排序的时间复杂度接近于线性时间 $ O(n) $。

#### 空间复杂度分析

基数排序的空间复杂度为 $ O(n + k) $，因为需要额外的空间来存储计数数组和输出数组。

#### 稳定性

基数排序是一种稳定的排序算法。稳定性在多关键字排序时非常重要，确保相同关键字的相对顺序在排序后保持不变。

#### 适用性

基数排序适用于以下情况：
1. **多关键字排序**：需要对多个关键字排序时，基数排序特别有效。
2. **大规模整数排序**：处理大规模整数数据时，基数排序的效率非常高。

#### 示例

假设有一个数组 `A = [329, 457, 657, 839, 436, 720, 355]`，我们使用基数排序对其进行排序。以下是具体操作步骤：

1. **对个位排序**：
   - 使用计数排序对个位进行排序，得到中间结果 `[720, 355, 436, 657, 457, 329, 839]`。

2. **对十位排序**：
   - 使用计数排序对十位进行排序，得到中间结果 `[329, 720, 839, 436, 355, 457, 657]`。

3. **对百位排序**：
   - 使用计数排序对百位进行排序，得到最终结果 `[329, 355, 436, 457, 657, 720, 839]`。

#### 总结

基数排序是一种高效的线性时间排序算法，特别适用于多关键字排序和大规模整数排序。其稳定性和线性时间复杂度使其在特定应用场景中非常有优势。理解基数排序的原理和实现，对于优化特定类型数据的排序性能具有重要意义。