
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>3.5.1 红黑树的性质</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>00_3.5.1_红黑树的性质</h1>
<pre><code>Lecture: 03._数据结构/3.5_红黑树
Content: 00_3.5.1_红黑树的性质
</code></pre>
<h3>3.5.1 红黑树的性质</h3>
<p>红黑树是一种自平衡二叉搜索树（BST），其设计目标是确保树的高度在最坏情况下保持对数级别，从而在插入、删除和查找操作中提供高效的性能。红黑树通过在每个节点上增加一个存储位表示“颜色”（红或黑），并在插入和删除节点时进行适当的旋转和重新着色操作来维持其平衡。</p>
<h4>红黑树的定义和性质</h4>
<p>红黑树具有以下性质：</p>
<ol>
<li>
<p><strong>每个节点是红色或黑色的</strong>：
每个节点除了包含常规的键值和子节点指针外，还包含一个颜色属性，这个颜色要么是红色，要么是黑色。</p>
</li>
<li>
<p><strong>根节点是黑色的</strong>：
红黑树的根节点总是黑色的。这一性质确保从根到叶节点的所有路径都包含相同数量的黑色节点，从而保证树的平衡性。</p>
</li>
<li>
<p><strong>所有叶节点（NIL）是黑色的</strong>：
红黑树中的叶节点（即空节点）被视为黑色。这一性质与根节点是黑色的性质共同作用，确保了树的黑色高度一致性。</p>
</li>
<li>
<p><strong>红色节点的子节点必须是黑色的（红色节点不能有红色子节点）</strong>：
这意味着红色节点不能相邻，红色节点的子节点和父节点必须是黑色的，从而避免了路径上连续红色节点的出现。</p>
</li>
<li>
<p><strong>从任一节点到其每个叶节点的所有简单路径都包含相同数量的黑色节点</strong>：
这一性质称为“黑色高度一致性”，它确保了从根到叶的最长路径不会超过最短路径的两倍，从而保证了树的平衡。</p>
</li>
</ol>
<h4>红黑树的高度</h4>
<p>由于红黑树的这些性质，可以证明一棵包含 $n$ 个节点的红黑树的高度至多为 $2\log(n+1)$。这种对数级别的高度使得红黑树的基本操作（查找、插入和删除）的时间复杂度均为 $O(\log n)$。</p>
<h4>红黑树的操作</h4>
<ol>
<li>
<p><strong>查找</strong>：
红黑树的查找操作与普通的二叉搜索树相同，时间复杂度为 $O(\log n)$。</p>
</li>
<li>
<p><strong>插入</strong>：
插入操作会在树中新增一个节点，并且这个新节点初始时总是红色的。为了维护红黑树的性质，可能需要进行若干次旋转和重新着色操作。具体步骤包括：</p>
<ul>
<li>插入新节点并着色为红色。</li>
<li>检查插入节点的父节点颜色，如果是黑色则结束；如果是红色，则需要进行调整。</li>
<li>通过旋转和重新着色操作调整树结构，确保红黑树的性质不被破坏。</li>
</ul>
</li>
<li>
<p><strong>删除</strong>：
删除操作相对复杂，因为删除节点后需要维护红黑树的平衡。具体步骤包括：</p>
<ul>
<li>找到并删除目标节点。</li>
<li>用其子节点（如果有）替代被删除的节点，并调整其颜色。</li>
<li>如果被删除的节点或其子节点是黑色，则需要进行额外的调整，通过旋转和重新着色操作恢复红黑树的平衡。</li>
</ul>
</li>
</ol>
<h4>旋转操作</h4>
<p>红黑树中的旋转操作分为左旋和右旋两种，旋转的目的是调整树的结构以维护红黑树的性质。</p>
<ol>
<li>
<p><strong>左旋</strong>：
左旋操作将某个节点向左下方移动，使其右子节点上升成为新的父节点。</p>
</li>
<li>
<p><strong>右旋</strong>：
右旋操作将某个节点向右下方移动，使其左子节点上升成为新的父节点。</p>
</li>
</ol>
<p>旋转操作本质上是局部调整，不改变中序遍历的结果，因此不会影响二叉搜索树的排序性质。</p>
<h3>总结</h3>
<p>红黑树通过引入颜色属性和一系列旋转和重新着色操作，确保树的高度在最坏情况下保持对数级别，从而提供了高效的查找、插入和删除操作。红黑树的五个关键性质保证了树的平衡性，使其成为一种广泛应用于各种实际场景的高效数据结构。通过理解红黑树的性质和操作，可以更好地掌握其在实际应用中的实现和优化。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_3.5.1_红黑树的性质

"""
Lecture: 03._数据结构/3.5_红黑树
Content: 00_3.5.1_红黑树的性质
"""

from typing import Optional, Any

class RedBlackTreeNode:
    """红黑树节点类，表示红黑树的一个节点。

    Attributes:
        key: 节点的键值。
        value: 节点的值。
        color: 节点的颜色，红色或黑色。
        left: 左子节点。
        right: 右子节点。
        parent: 父节点。
    """
    
    def __init__(self, key: int, value: Any, color: str) -> None:
        self.key = key
        self.value = value
        self.color = color
        self.left: Optional['RedBlackTreeNode'] = None
        self.right: Optional['RedBlackTreeNode'] = None
        self.parent: Optional['RedBlackTreeNode'] = None


class RedBlackTree:
    """红黑树类，提供插入和删除操作。

    Attributes:
        root: 树的根节点。
        TNULL: 哨兵节点，表示NIL。
    """
    
    def __init__(self) -> None:
        self.TNULL = RedBlackTreeNode(0, None, 'black')
        self.root: Optional[RedBlackTreeNode] = self.TNULL

    def _left_rotate(self, x: RedBlackTreeNode) -> None:
        """左旋操作。
        
        Args:
            x: 进行左旋的节点。
        """
        y = x.right
        x.right = y.left
        if y.left != self.TNULL:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def _right_rotate(self, x: RedBlackTreeNode) -> None:
        """右旋操作。
        
        Args:
            x: 进行右旋的节点。
        """
        y = x.left
        x.left = y.right
        if y.right != self.TNULL:
            y.right.parent = x
        y.parent = x.parent
        if x.parent is None:
            self.root = y
        elif x == x.parent.right:
            x.parent.right = y
        else:
            x.parent.left = y
        y.right = x
        x.parent = y

    def _fix_insert(self, k: RedBlackTreeNode) -> None:
        """插入修复红黑树的性质。
        
        Args:
            k: 新插入的节点。
        """
        while k.parent.color == 'red':
            if k.parent == k.parent.parent.right:
                u = k.parent.parent.left
                if u.color == 'red':
                    u.color = 'black'
                    k.parent.color = 'black'
                    k.parent.parent.color = 'red'
                    k = k.parent.parent
                else:
                    if k == k.parent.left:
                        k = k.parent
                        self._right_rotate(k)
                    k.parent.color = 'black'
                    k.parent.parent.color = 'red'
                    self._left_rotate(k.parent.parent)
            else:
                u = k.parent.parent.right
                if u.color == 'red':
                    u.color = 'black'
                    k.parent.color = 'black'
                    k.parent.parent.color = 'red'
                    k = k.parent.parent
                else:
                    if k == k.parent.right:
                        k = k.parent
                        self._left_rotate(k)
                    k.parent.color = 'black'
                    k.parent.parent.color = 'red'
                    self._right_rotate(k.parent.parent)
            if k == self.root:
                break
        self.root.color = 'black'

    def insert(self, key: int, value: Any) -> None:
        """插入键值对到红黑树中。
        
        Args:
            key: 键值。
            value: 对应的值。
        """
        node = RedBlackTreeNode(key, value, 'red')
        node.left = self.TNULL
        node.right = self.TNULL

        parent = None
        current = self.root

        while current != self.TNULL:
            parent = current
            if node.key < current.key:
                current = current.left
            else:
                current = current.right

        node.parent = parent
        if parent is None:
            self.root = node
        elif node.key < parent.key:
            parent.left = node
        else:
            parent.right = node

        if node.parent is None:
            node.color = 'black'
            return

        if node.parent.parent is None:
            return

        self._fix_insert(node)

    def _fix_delete(self, x: RedBlackTreeNode) -> None:
        """删除修复红黑树的性质。
        
        Args:
            x: 被删除的节点。
        """
        while x != self.root and x.color == 'black':
            if x == x.parent.left:
                s = x.parent.right
                if s.color == 'red':
                    s.color = 'black'
                    x.parent.color = 'red'
                    self._left_rotate(x.parent)
                    s = x.parent.right
                if s.left.color == 'black' and s.right.color == 'black':
                    s.color = 'red'
                    x = x.parent
                else:
                    if s.right.color == 'black':
                        s.left.color = 'black'
                        s.color = 'red'
                        self._right_rotate(s)
                        s = x.parent.right
                    s.color = x.parent.color
                    x.parent.color = 'black'
                    s.right.color = 'black'
                    self._left_rotate(x.parent)
                    x = self.root
            else:
                s = x.parent.left
                if s.color == 'red':
                    s.color = 'black'
                    x.parent.color = 'red'
                    self._right_rotate(x.parent)
                    s = x.parent.left
                if s.left.color == 'black' and s.right.color == 'black':
                    s.color = 'red'
                    x = x.parent
                else:
                    if s.left.color == 'black':
                        s.right.color = 'black'
                        s.color = 'red'
                        self._left_rotate(s)
                        s = x.parent.left
                    s.color = x.parent.color
                    x.parent.color = 'black'
                    s.left.color = 'black'
                    self._right_rotate(x.parent)
                    x = self.root
        x.color = 'black'

    def _transplant(self, u: RedBlackTreeNode, v: RedBlackTreeNode) -> None:
        """用节点v替换节点u。
        
        Args:
            u: 被替换的节点。
            v: 替换节点。
        """
        if u.parent is None:
            self.root = v
        elif u == u.parent.left:
            u.parent.left = v
        else:
            u.parent.right = v
        v.parent = u.parent

    def _delete_node_helper(self, node: RedBlackTreeNode, key: int) -> None:
        """删除红黑树中的节点。
        
        Args:
            node: 当前节点。
            key: 要删除的键值。
        """
        z = self.TNULL
        while node != self.TNULL:
            if node.key == key:
                z = node
            if node.key <= key:
                node = node.right
            else:
                node = node.left

        if z == self.TNULL:
            print("找不到键值:", key)
            return

        y = z
        y_original_color = y.color
        if z.left == self.TNULL:
            x = z.right
            self._transplant(z, z.right)
        elif z.right == self.TNULL:
            x = z.left
            self._transplant(z, z.left)
        else:
            y = self._find_minimum(z.right)
            y_original_color = y.color
            x = y.right
            if y.parent == z:
                x.parent = y
            else:
                self._transplant(y, y.right)
                y.right = z.right
                y.right.parent = y

            self._transplant(z, y)
            y.left = z.left
            y.left.parent = y
            y.color = z.color

        if y_original_color == 'black':
            self._fix_delete(x)

    def delete(self, key: int) -> None:
        """删除红黑树中的节点。
        
        Args:
            key: 要删除的键值。
        """
        self._delete_node_helper(self.root, key)

    def _find_minimum(self, node: RedBlackTreeNode) -> RedBlackTreeNode:
        """查找并返回红黑树中的最小节点。
        
        Args:
            node: 当前节点。
        
        Returns:
            最小节点。
        """
        while node.left != self.TNULL:
            node = node.left
        return node

    def _find_maximum(self, node: RedBlackTreeNode) -> RedBlackTreeNode:
        """查找并返回红黑树中的最大节点。
        
        Args:
            node: 当前节点。
        
        Returns:
            最大节点。
        """
        while node.right != self.TNULL:
            node = node.right
        return node</code></pre>
  </div>
</body>
</html>
  