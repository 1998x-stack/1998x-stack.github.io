
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>01-complexity</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <blockquote>
<p>各种排序的复杂度最优最差平均</p>
</blockquote>
<h3>各种排序算法的复杂度分析</h3>
<p>以下是常见排序算法的时间复杂度和空间复杂度的对比，包括它们的最优、最差和平均时间复杂度。</p>
<h4>1. 冒泡排序（Bubble Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n)（当数组已经有序时，只需一次遍历）</li>
<li><strong>最差时间复杂度</strong>：O(n^2)</li>
<li><strong>平均时间复杂度</strong>：O(n^2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<h4>2. 选择排序（Selection Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n^2)</li>
<li><strong>最差时间复杂度</strong>：O(n^2)</li>
<li><strong>平均时间复杂度</strong>：O(n^2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<h4>3. 插入排序（Insertion Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n)（当数组已经有序时）</li>
<li><strong>最差时间复杂度</strong>：O(n^2)</li>
<li><strong>平均时间复杂度</strong>：O(n^2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<h4>4. 归并排序（Merge Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n log n)</li>
<li><strong>最差时间复杂度</strong>：O(n log n)</li>
<li><strong>平均时间复杂度</strong>：O(n log n)</li>
<li><strong>空间复杂度</strong>：O(n)（需要额外的数组存储合并结果）</li>
</ul>
<h4>5. 快速排序（Quick Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n log n)</li>
<li><strong>最差时间复杂度</strong>：O(n^2)（当每次选择的基准都位于最差位置时）</li>
<li><strong>平均时间复杂度</strong>：O(n log n)</li>
<li><strong>空间复杂度</strong>：O(log n)（递归栈的空间）</li>
</ul>
<h4>6. 堆排序（Heap Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n log n)</li>
<li><strong>最差时间复杂度</strong>：O(n log n)</li>
<li><strong>平均时间复杂度</strong>：O(n log n)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<h4>7. 计数排序（Counting Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n + k)（k 是数组中元素的最大值）</li>
<li><strong>最差时间复杂度</strong>：O(n + k)</li>
<li><strong>平均时间复杂度</strong>：O(n + k)</li>
<li><strong>空间复杂度</strong>：O(k)</li>
</ul>
<h4>8. 基数排序（Radix Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(nk)（k 是数字的位数）</li>
<li><strong>最差时间复杂度</strong>：O(nk)</li>
<li><strong>平均时间复杂度</strong>：O(nk)</li>
<li><strong>空间复杂度</strong>：O(n + k)</li>
</ul>
<h4>9. 桶排序（Bucket Sort）</h4>
<ul>
<li><strong>最优时间复杂度</strong>：O(n + k)（k 是桶的数量）</li>
<li><strong>最差时间复杂度</strong>：O(n^2)（所有元素都分配到一个桶中）</li>
<li><strong>平均时间复杂度</strong>：O(n + k)</li>
<li><strong>空间复杂度</strong>：O(n + k)</li>
</ul>
<h3>总结</h3>
<p>不同的排序算法在不同的情况下有不同的表现。以下是一些选择排序算法的建议：</p>
<ul>
<li><strong>小规模数据</strong>：插入排序和选择排序较为简单，适用于小规模数据。</li>
<li><strong>大规模数据</strong>：快速排序、归并排序和堆排序是常见的高效排序算法。</li>
<li><strong>稳定排序需求</strong>：归并排序和插入排序是稳定的，而快速排序和堆排序通常不是稳定的。</li>
<li><strong>特殊数据分布</strong>：对于特定的数据分布，如范围较小的整数数组，计数排序、基数排序。</li>
</ul>
<h3>各种排序算法的复杂度和应用场景比较表</h3>
<p>以下是常见排序算法的时间复杂度、空间复杂度以及适用的应用场景：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最优时间复杂度</th>
<th>最差时间复杂度</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>适用于小型数据集和几乎有序的序列。</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>适用于数据量小且对排序稳定性要求不高的场合。</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>适用于小型数据集和基本有序的数据。</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>适用于排序链表或稳定性要求高的场合。</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n^2)</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td>不稳定</td>
<td>适用于大多数情况，是常用的通用排序算法。</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>适用于数据量大且对空间复杂度要求高的场合。</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(k)</td>
<td>稳定</td>
<td>适用于范围较小的整数排序。</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(n + k)</td>
<td>稳定</td>
<td>适用于数据范围大但位数相对较小的整数排序。</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n + k)</td>
<td>O(n^2)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>稳定</td>
<td>适用于数据分布均匀的场合。</td>
</tr>
</tbody>
</table>
<h3>解释和应用场景</h3>
<ol>
<li>
<p><strong>冒泡排序</strong>（Bubble Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于小型数据集和几乎有序的序列。</li>
<li><strong>优缺点</strong>：简单易实现，但在大多数情况下性能较差。</li>
</ul>
</li>
<li>
<p><strong>选择排序</strong>（Selection Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于数据量小且对排序稳定性要求不高的场合。</li>
<li><strong>优缺点</strong>：简单易实现，但在任何情况下性能都较差，不适合大规模数据。</li>
</ul>
</li>
<li>
<p><strong>插入排序</strong>（Insertion Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于小型数据集和基本有序的数据。</li>
<li><strong>优缺点</strong>：在数据接近有序时非常高效，但在数据无序时性能较差。</li>
</ul>
</li>
<li>
<p><strong>归并排序</strong>（Merge Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于排序链表或稳定性要求高的场合。</li>
<li><strong>优缺点</strong>：性能稳定，但需要额外的内存空间。</li>
</ul>
</li>
<li>
<p><strong>快速排序</strong>（Quick Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于大多数情况，是常用的通用排序算法。</li>
<li><strong>优缺点</strong>：平均性能优越，但在最差情况下性能较差。</li>
</ul>
</li>
<li>
<p><strong>堆排序</strong>（Heap Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于数据量大且对空间复杂度要求高的场合。</li>
<li><strong>优缺点</strong>：不需要额外的内存空间，但性能不如快速排序。</li>
</ul>
</li>
<li>
<p><strong>计数排序</strong>（Counting Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于范围较小的整数排序。</li>
<li><strong>优缺点</strong>：在数据范围较小时非常高效，但数据范围大时效率低下。</li>
</ul>
</li>
<li>
<p><strong>基数排序</strong>（Radix Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于数据范围大但位数相对较小的整数排序。</li>
<li><strong>优缺点</strong>：对数据位数敏感，但在特定条件下非常高效。</li>
</ul>
</li>
<li>
<p><strong>桶排序</strong>（Bucket Sort）：</p>
<ul>
<li><strong>应用场景</strong>：适用于数据分布均匀的场合。</li>
<li><strong>优缺点</strong>：在数据分布均匀时非常高效，但在数据分布不均时性能较差。</li>
</ul>
</li>
</ol>
<h3>参考文献</h3>
<ol>
<li>
<p><strong>GeeksforGeeks - Sorting Algorithms</strong>：</p>
<ul>
<li>提供了详细的排序算法解释和实现。</li>
<li><a href="https://www.geeksforgeeks.org/sorting-algorithms/">链接</a></li>
</ul>
</li>
<li>
<p><strong>LeetCode Discuss - Sorting Algorithms Complexity</strong>：</p>
<ul>
<li>提供了各种排序算法的时间和空间复杂度的详细讨论。</li>
<li><a href="https://leetcode.com/discuss/general-discussion/467728/sorting-algorithms-complexity-and-intuition/">LeetCode链接</a></li>
</ul>
</li>
</ol>

    <h3>Python 文件</h3>
    <pre><code>对应的 Python 文件不存在。</code></pre>
  </div>
</body>
</html>
  