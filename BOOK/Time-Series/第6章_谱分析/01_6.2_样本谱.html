
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>6.2 样本谱</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>01_6.2 样本谱</h1>
<pre><code>Lecture: /第6章 谱分析
Content: 01_6.2 样本谱
</code></pre>
<h2>6.2 样本谱极致详细解析</h2>
<h3>1. 样本谱概述</h3>
<p>样本谱（Sample Spectrum）是对实际观测数据进行频域分析的重要工具。通过样本谱，可以估计时间序列在不同频率上的能量分布，从而了解其频域特性。样本谱是总体谱的一个样本估计量，通常通过计算周期图（Periodogram）来实现。</p>
<h3>2. 样本谱的数学定义</h3>
<p>假设我们有一个长度为 $n$ 的时间序列 ${x_t}$，其样本谱 $I_n(\lambda)$ 定义为：
$$ I_n(\lambda) = \frac{1}{n} \left| \sum_{t=1}^n x_t e^{-it\lambda} \right|^2 $$
其中 $\lambda$ 表示频率，$t$ 表示时间索引。这个定义实际上是傅里叶变换的模平方，通过计算每个频率处的能量来估计时间序列的频谱特性。</p>
<h3>3. 样本谱的性质</h3>
<p>样本谱具有以下性质：</p>
<ol>
<li><strong>无偏性</strong>：样本谱是总体谱的无偏估计量，即在大样本量下，样本谱的期望值等于总体谱。</li>
<li><strong>一致性</strong>：随着样本量 $n$ 的增加，样本谱 $I_n(\lambda)$ 会一致收敛于总体谱 $f(\lambda)$。</li>
<li><strong>频率分辨率</strong>：样本谱的频率分辨率取决于样本长度 $n$，较长的样本长度可以提供更好的频率分辨率。</li>
</ol>
<h3>4. 样本谱的计算方法</h3>
<p>计算样本谱的步骤如下：</p>
<h4>4.1 计算离散傅里叶变换（DFT）</h4>
<p>首先，对时间序列 ${x_t}$ 进行离散傅里叶变换（DFT）：
$$ X_k = \sum_{t=1}^n x_t e^{-i 2\pi kt / n}, \quad k = 0, 1, \ldots, n-1 $$
其中 $X_k$ 是频率为 $2\pi k / n$ 处的傅里叶系数。</p>
<h4>4.2 计算周期图</h4>
<p>根据傅里叶系数，计算周期图：
$$ I_n(\lambda_k) = \frac{1}{n} |X_k|^2, \quad \lambda_k = \frac{2\pi k}{n} $$
其中 $k$ 是频率索引。</p>
<h3>5. 样本谱的应用</h3>
<p>样本谱在实际应用中具有广泛用途，以下是几个典型应用场景：</p>
<h4>5.1 检测周期性成分</h4>
<p>通过样本谱，可以识别时间序列中的周期性成分。例如，在经济数据分析中，可以通过样本谱检测季度或年度周期。</p>
<h4>5.2 结构设计中的应用</h4>
<p>在结构设计中，通过分析载荷力的样本谱，可以识别显著的正弦分量，从而避免结构共振频率的存在。</p>
<h4>5.3 信号处理中的应用</h4>
<p>在信号处理领域，样本谱用于信号去噪、滤波和特征提取。例如，在语音信号处理中，通过分析语音信号的样本谱，可以实现语音识别和语音增强。</p>
<h3>6. 样本谱的局限性</h3>
<p>尽管样本谱在频域分析中具有重要作用，但其也存在一些局限性：</p>
<ol>
<li><strong>频谱泄漏</strong>：由于时间序列的有限长度，样本谱计算中可能会出现频谱泄漏现象，导致频率分辨率降低。</li>
<li><strong>噪声影响</strong>：样本谱对噪声较为敏感，可能会引入不准确的频谱成分。</li>
<li><strong>窗口函数选择</strong>：为了减少频谱泄漏，通常会引入窗口函数（如Hamming窗、Hanning窗等），但不同的窗口函数会对结果产生不同影响。</li>
</ol>
<h3>7. 样本谱估计的改进方法</h3>
<p>为了克服样本谱的局限性，可以采用以下改进方法：</p>
<h4>7.1 平滑处理</h4>
<p>对样本谱进行平滑处理可以减少频谱泄漏。例如，可以使用移动平均平滑或其他平滑技术来平滑周期图。</p>
<h4>7.2 多重窗口技术</h4>
<p>采用多重窗口技术（如多重谐波分析）可以提高频谱估计的精度。通过对不同窗口函数下的样本谱进行加权平均，可以获得更加平滑和准确的频谱估计。</p>
<h4>7.3 自回归谱估计</h4>
<p>自回归谱估计是一种基于自回归模型的频谱估计方法。通过拟合自回归模型，可以估计时间序列的自回归系数，从而计算频谱。自回归谱估计通常具有较高的频率分辨率。</p>
<h3>8. 结论</h3>
<p>样本谱作为时间序列频域分析的重要工具，通过计算周期图提供了对时间序列频率特性的估计。在实际应用中，样本谱可以用于检测周期性成分、分析结构共振频率、进行信号处理等。然而，样本谱也存在频谱泄漏和噪声影响等局限性，需要通过平滑处理、多重窗口技术和自回归谱估计等方法进行改进。</p>

    <h3>Python 文件</h3>
    <pre><code># 01_6.2 样本谱

"""
Lecture: /第6章 谱分析
Content: 01_6.2 样本谱
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple

class SampleSpectrum:
    def __init__(self, n: int, seed: int = 0) -> None:
        """
        初始化样本谱类

        参数:
        n (int): 序列长度
        seed (int): 随机种子
        """
        np.random.seed(seed)
        self.n = n
        self.time = np.arange(n)

    def generate_white_noise(self, mean: float = 0, std: float = 1) -> np.ndarray:
        """
        生成白噪声序列

        参数:
        mean (float): 均值
        std (float): 标准差

        返回:
        np.ndarray: 白噪声序列
        """
        return np.random.normal(mean, std, self.n)

    def generate_ar1(self, phi: float, mean: float = 0, std: float = 1) -> np.ndarray:
        """
        生成AR(1)过程

        参数:
        phi (float): AR参数
        mean (float): 噪声均值
        std (float): 噪声标准差

        返回:
        np.ndarray: AR(1)序列
        """
        ar1_series = np.zeros(self.n)
        noise = np.random.normal(mean, std, self.n)
        for t in range(1, self.n):
            ar1_series[t] = phi * ar1_series[t-1] + noise[t]
        return ar1_series

    def generate_ma1(self, theta: float, mean: float = 0, std: float = 1) -> np.ndarray:
        """
        生成MA(1)过程

        参数:
        theta (float): MA参数
        mean (float): 噪声均值
        std (float): 噪声标准差

        返回:
        np.ndarray: MA(1)序列
        """
        ma1_series = np.zeros(self.n)
        noise = np.random.normal(mean, std, self.n)
        for t in range(1, self.n):
            ma1_series[t] = noise[t] + theta * noise[t-1]
        return ma1_series

    def compute_periodogram(self, series: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        计算序列的周期图

        参数:
        series (np.ndarray): 输入序列

        返回:
        Tuple[np.ndarray, np.ndarray]: 频率和功率谱密度
        """
        n = len(series)
        frequencies = np.fft.fftfreq(n)
        spectrum = np.abs(np.fft.fft(series))**2 / n
        return frequencies[:n // 2], spectrum[:n // 2]

    def plot_time_series(self, series: np.ndarray, title: str) -> None:
        """
        绘制时间序列

        参数:
        series (np.ndarray): 输入序列
        title (str): 图表标题
        """
        plt.plot(self.time, series)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Amplitude")
        plt.grid(True)

    def plot_periodogram(self, frequencies: np.ndarray, spectrum: np.ndarray, title: str) -> None:
        """
        绘制周期图

        参数:
        frequencies (np.ndarray): 频率
        spectrum (np.ndarray): 功率谱密度
        title (str): 图表标题
        """
        plt.semilogy(frequencies, spectrum)
        plt.title(title)
        plt.xlabel("Frequency")
        plt.ylabel("Power Spectral Density")
        plt.grid(True)


def main() -> None:
    """
    主函数：生成并分析白噪声、AR(1)和MA(1)过程，绘制其时域图和频域图。
    """
    n = 1000
    analysis = SampleSpectrum(n)

    # 生成序列
    white_noise = analysis.generate_white_noise()
    ar1_series = analysis.generate_ar1(phi=0.5)
    ma1_series = analysis.generate_ma1(theta=0.5)

    # 绘制时域图
    plt.figure(figsize=(12, 8))

    plt.subplot(3, 2, 1)
    analysis.plot_time_series(white_noise, "White Noise (Time Domain)")

    plt.subplot(3, 2, 3)
    analysis.plot_time_series(ar1_series, "AR(1) Process (Time Domain)")

    plt.subplot(3, 2, 5)
    analysis.plot_time_series(ma1_series, "MA(1) Process (Time Domain)")

    # 计算并绘制频域图
    frequencies_wn, spectrum_wn = analysis.compute_periodogram(white_noise)
    frequencies_ar1, spectrum_ar1 = analysis.compute_periodogram(ar1_series)
    frequencies_ma1, spectrum_ma1 = analysis.compute_periodogram(ma1_series)

    plt.subplot(3, 2, 2)
    analysis.plot_periodogram(frequencies_wn, spectrum_wn, "White Noise (Frequency Domain)")

    plt.subplot(3, 2, 4)
    analysis.plot_periodogram(frequencies_ar1, spectrum_ar1, "AR(1) Process (Frequency Domain)")

    plt.subplot(3, 2, 6)
    analysis.plot_periodogram(frequencies_ma1, spectrum_ma1, "MA(1) Process (Frequency Domain)")

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()</code></pre>
  </div>
</body>
</html>
  