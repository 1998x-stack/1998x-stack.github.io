
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>7.2.1 P R曲线</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>00_7.2.1 P-R曲线</h1>
<pre><code>Lecture: 第7章 推荐系统的评估/7.2 直接评估推荐序列的离线指标
Content: 00_7.2.1 P-R曲线
</code></pre>
<h3>7.2.1 P-R曲线</h3>
<h4>概述</h4>
<p>P-R曲线，即精确率-召回率曲线（Precision-Recall Curve），是评估推荐系统性能的一种重要工具。P-R曲线展示了在不同的阈值下，推荐系统的精确率和召回率的变化关系。通过分析P-R曲线，可以更全面地了解推荐系统在不同条件下的表现，从而优化推荐算法。</p>
<h4>精确率和召回率</h4>
<ol>
<li>
<p><strong>精确率（Precision）</strong>：</p>
<ul>
<li><strong>定义</strong>：精确率是指推荐结果中相关项目所占的比例。</li>
<li><strong>计算公式</strong>：
$$
Precision = \frac{TP}{TP + FP}
$$
其中，TP为真正例数，FP为假正例数。</li>
<li><strong>作用</strong>：反映推荐结果的准确性，适用于推荐结果较短的情况。</li>
</ul>
</li>
<li>
<p><strong>召回率（Recall）</strong>：</p>
<ul>
<li><strong>定义</strong>：召回率是指实际相关项目中被推荐的比例。</li>
<li><strong>计算公式</strong>：
$$
Recall = \frac{TP}{TP + FN}
$$
其中，TP为真正例数，FN为假负例数。</li>
<li><strong>作用</strong>：反映推荐系统的覆盖能力，适用于需要全面推荐的情况。</li>
</ul>
</li>
</ol>
<h4>P-R曲线的绘制</h4>
<ol>
<li>
<p><strong>数据准备</strong>：</p>
<ul>
<li><strong>预测评分</strong>：推荐系统对所有候选项目进行预测评分。</li>
<li><strong>实际标签</strong>：实际的用户行为数据，表示哪些项目是相关的，哪些是无关的。</li>
</ul>
</li>
<li>
<p><strong>计算精确率和召回率</strong>：</p>
<ul>
<li>设定不同的评分阈值，对每个阈值计算相应的精确率和召回率。</li>
<li>生成一组精确率和召回率的点，作为P-R曲线的坐标点。</li>
</ul>
</li>
<li>
<p><strong>绘制P-R曲线</strong>：</p>
<ul>
<li>将所有坐标点绘制在二维平面上，横轴为召回率，纵轴为精确率。</li>
<li>连接这些点，形成P-R曲线。</li>
</ul>
</li>
</ol>
<h4>P-R曲线的分析</h4>
<ol>
<li>
<p><strong>曲线形状</strong>：</p>
<ul>
<li>曲线越接近右上角，表示推荐系统的性能越好，即在高召回率的同时，能够保持高精确率。</li>
<li>曲线的变化反映了推荐系统在不同阈值下的性能表现，帮助识别最佳的评分阈值。</li>
</ul>
</li>
<li>
<p><strong>AUC值</strong>：</p>
<ul>
<li>P-R曲线下的面积（Area Under Curve, AUC）可以量化推荐系统的整体性能。</li>
<li>AUC值越大，表示推荐系统的综合性能越好。</li>
</ul>
</li>
<li>
<p><strong>对比分析</strong>：</p>
<ul>
<li>不同推荐算法的P-R曲线可以放在一起对比，评估不同算法的优劣。</li>
<li>通过对比，可以选择性能最优的推荐算法。</li>
</ul>
</li>
</ol>
<h4>实际应用案例</h4>
<ol>
<li>
<p><strong>电商推荐系统</strong>：</p>
<ul>
<li>某电商平台在优化推荐算法时，使用P-R曲线评估不同算法的性能。通过对比不同算法的P-R曲线，选择在高召回率下仍能保持高精确率的算法，提升用户的购物体验。</li>
</ul>
</li>
<li>
<p><strong>内容推荐系统</strong>：</p>
<ul>
<li>某内容平台在推荐文章和视频时，使用P-R曲线分析推荐结果的精确率和召回率。通过调整评分阈值，找到最佳的推荐策略，确保用户能够看到更多相关的内容。</li>
</ul>
</li>
<li>
<p><strong>社交网络推荐系统</strong>：</p>
<ul>
<li>某社交网络平台在好友推荐和群组推荐中，使用P-R曲线评估推荐系统的性能。通过分析P-R曲线，优化推荐算法，提高用户的互动和参与度。</li>
</ul>
</li>
</ol>
<h3>总结</h3>
<p>P-R曲线是评估推荐系统性能的重要工具，通过展示精确率和召回率在不同阈值下的变化关系，帮助工程师更全面地了解推荐系统的表现。通过分析P-R曲线的形状和AUC值，可以优化推荐算法，提升推荐系统的性能。在未来，随着推荐系统技术的发展，P-R曲线将继续在评估和优化推荐系统中发挥重要作用。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_7.2.1 P-R曲线

"""
Lecture: 第7章 推荐系统的评估/7.2 直接评估推荐序列的离线指标
Content: 00_7.2.1 P-R曲线
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple


class PrecisionRecallCurve:
    """
    Precision-Recall Curve Class
    
    该类用于计算和绘制精确率-召回率曲线（P-R曲线）。
    """

    def __init__(self, y_true: List[int], y_scores: List[float]) -> None:
        """
        初始化PrecisionRecallCurve类
        
        Args:
            y_true (List[int]): 实际标签列表
            y_scores (List[float]): 预测得分列表
        """
        self.y_true = np.array(y_true)
        self.y_scores = np.array(y_scores)
        self.precision_recall_points = self._calculate_precision_recall()

    def _calculate_precision_recall(self) -> List[Tuple[float, float]]:
        """
        计算不同阈值下的精确率和召回率
        
        Returns:
            List[Tuple[float, float]]: 精确率和召回率的列表
        """
        thresholds = np.sort(self.y_scores)[::-1]
        precision_recall_points = []

        for threshold in thresholds:
            y_pred = self.y_scores >= threshold
            tp = np.sum((self.y_true == 1) & (y_pred == 1))
            fp = np.sum((self.y_true == 0) & (y_pred == 1))
            fn = np.sum((self.y_true == 1) & (y_pred == 0))

            precision = tp / (tp + fp) if (tp + fp) > 0 else 0.0
            recall = tp / (fn + tp) if (fn + tp) > 0 else 0.0

            precision_recall_points.append((precision, recall))

        return precision_recall_points

    def plot_precision_recall_curve(self) -> None:
        """
        绘制精确率-召回率曲线
        
        """
        precisions, recalls = zip(*self.precision_recall_points)
        
        plt.figure(figsize=(8, 6))
        plt.plot(recalls, precisions, marker='.')
        plt.xlabel('召回率 (Recall)')
        plt.ylabel('精确率 (Precision)')
        plt.title('精确率-召回率曲线 (P-R Curve)')
        plt.grid(True)
        plt.show()

    def calculate_auc(self) -> float:
        """
        计算P-R曲线下的面积（AUC）
        
        Returns:
            float: AUC值
        """
        precisions, recalls = zip(*self.precision_recall_points)
        return np.trapz(precisions, recalls)


# 示例使用
if __name__ == "__main__":
    # 实际标签
    y_true = [0, 1, 1, 0, 1, 0, 0, 1, 1, 0]

    # 预测得分
    y_scores = [0.1, 0.4, 0.35, 0.8, 0.45, 0.2, 0.5, 0.9, 0.7, 0.3]

    # 创建PrecisionRecallCurve实例
    pr_curve = PrecisionRecallCurve(y_true, y_scores)

    # 打印计算的精确率和召回率
    print("精确率和召回率: ", pr_curve.precision_recall_points)

    # 绘制P-R曲线
    pr_curve.plot_precision_recall_curve()

    # 计算并打印AUC值
    auc_value = pr_curve.calculate_auc()
    print(f"P-R曲线下的面积 (AUC): {auc_value:.4f}")</code></pre>
  </div>
</body>
</html>
  