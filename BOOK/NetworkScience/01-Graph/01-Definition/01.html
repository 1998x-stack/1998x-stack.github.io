
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>01</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <p>好的，以下是对您提供的图的集合论定义部分的详细展开：</p>
<h3>2.1 图的集合论定义</h3>
<p>在这一部分，我们将探讨图论中一些基础的集合论概念和定义。这些概念是理解图结构和图算法的基础。</p>
<h4>2.1.1 节点、链路和映射函数</h4>
<ul>
<li>
<p><strong>节点（Vertex）</strong>：
节点是图中的基本单位，表示一个对象或一个位置。在图中，节点通常用一个唯一的标识符表示，如数字或字母。</p>
</li>
<li>
<p><strong>链路（Edge）</strong>：
链路是连接两个节点的连线，表示两个对象之间的关系或路径。链路可以是有向的（表示方向）或无向的（不表示方向）。</p>
</li>
<li>
<p><strong>映射函数（Mapping Function）</strong>：
映射函数用于定义节点和链路之间的关系。它可以是一个简单的映射，如节点到节点的对应关系，或者是复杂的映射，如节点属性到节点属性的映射。</p>
</li>
</ul>
<h4>2.1.2 节点度和hub</h4>
<ul>
<li>
<p><strong>节点度（Degree）</strong>：
节点度是指一个节点的邻居节点数量。在无向图中，节点度是该节点连接的边的数量。在有向图中，分为入度和出度，分别表示进入该节点和从该节点出发的边的数量。</p>
</li>
<li>
<p><strong>hub（枢纽节点）</strong>：
hub是指在图中具有高节点度的节点，这些节点在图的连接性和信息传播中起到关键作用。</p>
</li>
</ul>
<h4>2.1.3 路径和回路</h4>
<ul>
<li>
<p><strong>路径（Path）</strong>：
路径是图中两个节点之间的一系列连续的边。路径的长度由路径中边的数量决定。在有向图中，路径必须遵循边的方向。</p>
</li>
<li>
<p><strong>回路（Cycle）</strong>：
回路是一种特殊的路径，其起点和终点是同一个节点。回路表示在图中存在一个封闭的路径。</p>
</li>
</ul>
<h4>2.1.4 连通性和组件</h4>
<ul>
<li>
<p><strong>连通性（Connectivity）</strong>：
连通性描述了图中节点之间是否存在路径。如果图中任意两个节点之间都有路径，则称该图是连通的。</p>
</li>
<li>
<p><strong>组件（Component）</strong>：
组件是图中最大连通子图。一个图可以由多个不相连的组件组成。</p>
</li>
</ul>
<h4>2.1.5 直径、半径和中心性</h4>
<ul>
<li>
<p><strong>直径（Diameter）</strong>：
图的直径是指图中任意两个节点之间的最短路径的最大值。它表示图中最远的节点之间的距离。</p>
</li>
<li>
<p><strong>半径（Radius）</strong>：
图的半径是指图中某个节点到所有其他节点的最短路径的最大值的最小值。它表示图中距离其他节点最短的节点的最大距离。</p>
</li>
<li>
<p><strong>中心性（Centrality）</strong>：
中心性衡量节点在图中的重要程度。常见的中心性指标包括度中心性、接近中心性和介数中心性。</p>
</li>
</ul>
<h4>2.1.6 介数和紧度</h4>
<ul>
<li>
<p><strong>介数（Betweenness）</strong>：
介数是指一个节点在图中充当桥梁的程度。它衡量了一个节点在多少条最短路径上起到中介作用。</p>
</li>
<li>
<p><strong>紧度（Closeness）</strong>：
紧度是指一个节点到所有其他节点的平均最短路径长度。紧度越高，表示节点在图中的位置越中心。</p>
</li>
</ul>
<h3>详细展开每个小节</h3>
<h4>2.1.1 节点、链路和映射函数</h4>
<p>在图论中，节点和链路是最基本的元素。节点表示图中的对象，而链路表示对象之间的关系。映射函数用于描述这些关系的具体形式。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>社交网络图：节点表示用户，链路表示用户之间的友谊关系。</li>
<li>交通网络图：节点表示城市，链路表示城市之间的道路。</li>
</ul>
<p>映射函数可以表示节点属性到节点属性的映射。例如，在社交网络图中，映射函数可以表示用户之间的互动次数。</p>
<h4>2.1.2 节点度和hub</h4>
<p>节点度是衡量节点在图中重要性的一个基本指标。度高的节点通常在图中具有更高的连接性，在信息传播和网络稳健性方面起着重要作用。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>在社交网络中，具有大量朋友的用户就是hub。</li>
<li>在互联网中，拥有大量链接的服务器就是hub。</li>
</ul>
<p>hub节点在图的分析中非常重要，因为它们可以影响整个网络的动态行为。</p>
<h4>2.1.3 路径和回路</h4>
<p>路径和回路是图中节点之间连接关系的重要表现形式。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>在交通网络中，从一个城市到另一个城市的行驶路线就是路径。</li>
<li>在电路图中，电流从电源经过各个元件回到电源的路径就是回路。</li>
</ul>
<p>路径和回路在优化问题中非常重要，如最短路径问题、旅行商问题等。</p>
<h4>2.1.4 连通性和组件</h4>
<p>连通性描述了图的整体结构和节点之间的可达性。连通图和不连通图在性质上有很大的区别。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>在网络中，连通性差的网络容易分裂成多个独立的子网。</li>
<li>在生物网络中，连通性高的网络表示生物体内不同系统之间的高效协作。</li>
</ul>
<p>组件是分析图结构的重要概念，有助于理解图的分层结构和局部特性。</p>
<h4>2.1.5 直径、半径和中心性</h4>
<p>这些概念用于描述图中节点间的距离和节点的重要性。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>在社交网络中，直径表示网络中最远的两个人之间的距离。</li>
<li>在物流网络中，半径小的城市表示物流中心。</li>
<li>中心性高的节点表示在网络中具有关键影响力的节点。</li>
</ul>
<h4>2.1.6 介数和紧度</h4>
<p>介数和紧度是衡量节点在图中位置和功能的重要指标。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>在通信网络中，介数高的节点表示信息传递的关键节点。</li>
<li>在交通网络中，紧度高的城市表示交通方便、到达其他城市迅速的城市。</li>
</ul>
<p>这些指标在网络优化、信息传播、病毒防控等领域有广泛应用。</p>
<h3>总结</h3>
<p>以上是对图的集合论定义部分的详细展开。理解这些基础概念有助于更深入地研究图论中的复杂问题和算法。图论在计算机科学、社会网络分析、生物信息学等多个领域有着广泛的应用。</p>

    <h3>Python 文件</h3>
    <pre><code>import numpy as np
from typing import List, Tuple, Dict

class Graph:
    def __init__(self, adj_matrix: np.ndarray):
        """
        初始化图对象

        参数:
            adj_matrix: 图的邻接矩阵表示
        """
        self.adj_matrix = adj_matrix.astype(float)
        self.num_vertices = adj_matrix.shape[0]

    def get_nodes(self) -> List[int]:
        """
        获取图的所有节点

        返回:
            图中所有节点的列表
        """
        return list(range(self.num_vertices))

    def get_edges(self) -> List[Tuple[int, int, float]]:
        """
        获取图的所有边

        返回:
            图中所有边的列表，包含边的起点、终点和权重
        """
        edges = []
        for i in range(self.num_vertices):
            for j in range(self.num_vertices):
                if self.adj_matrix[i, j] != 0:
                    edges.append((i, j, self.adj_matrix[i, j]))
        return edges

    def get_degrees(self) -> List[int]:
        """
        获取每个节点的度数

        返回:
            每个节点的度数列表
        """
        return np.sum(self.adj_matrix != 0, axis=1).tolist()

    def get_hub_nodes(self) -> List[int]:
        """
        获取hub节点，即度数最高的节点

        返回:
            hub节点的列表
        """
        degrees = self.get_degrees()
        max_degree = max(degrees)
        return [i for i, degree in enumerate(degrees) if degree == max_degree]

    def find_paths(self, start: int, end: int, path: List[int] = []) -> List[List[int]]:
        """
        查找从起点到终点的所有路径

        参数:
            start: 起点
            end: 终点
            path: 当前路径

        返回:
            所有路径的列表
        """
        path = path + [start]
        if start == end:
            return [path]
        if start >= self.num_vertices:
            return []
        paths = []
        for node in range(self.num_vertices):
            if self.adj_matrix[start][node] != 0 and node not in path:
                new_paths = self.find_paths(node, end, path)
                for p in new_paths:
                    paths.append(p)
        return paths

    def has_cycle(self) -> bool:
        """
        检测图中是否存在回路

        返回:
            如果存在回路则返回True，否则返回False
        """
        def visit(node, visited, stack):
            visited[node] = True
            stack[node] = True
            for neighbor in range(self.num_vertices):
                if self.adj_matrix[node][neighbor] != 0:
                    if not visited[neighbor]:
                        if visit(neighbor, visited, stack):
                            return True
                    elif stack[neighbor]:
                        return True
            stack[node] = False
            return False

        visited = [False] * self.num_vertices
        stack = [False] * self.num_vertices
        for node in range(self.num_vertices):
            if not visited[node]:
                if visit(node, visited, stack):
                    return True
        return False

    def is_connected(self) -> bool:
        """
        检测图是否是连通的

        返回:
            如果图是连通的则返回True，否则返回False
        """
        def dfs(node, visited):
            visited[node] = True
            for neighbor in range(self.num_vertices):
                if self.adj_matrix[node][neighbor] != 0 and not visited[neighbor]:
                    dfs(neighbor, visited)

        visited = [False] * self.num_vertices
        dfs(0, visited)
        return all(visited)

    def get_components(self) -> List[List[int]]:
        """
        获取图的所有连通组件

        返回:
            所有连通组件的列表，每个组件是一个节点列表
        """
        def dfs(node, visited, component):
            visited[node] = True
            component.append(node)
            for neighbor in range(self.num_vertices):
                if self.adj_matrix[node][neighbor] != 0 and not visited[neighbor]:
                    dfs(neighbor, visited, component)

        visited = [False] * self.num_vertices
        components = []
        for node in range(self.num_vertices):
            if not visited[node]:
                component = []
                dfs(node, visited, component)
                components.append(component)
        return components

    def get_shortest_paths(self) -> np.ndarray:
        """
        使用Floyd-Warshall算法计算所有节点对之间的最短路径

        返回:
            所有节点对之间的最短路径矩阵
        """
        dist = np.copy(self.adj_matrix)
        dist[dist == 0] = np.inf
        np.fill_diagonal(dist, 0)
        for k in range(self.num_vertices):
            for i in range(self.num_vertices):
                for j in range(self.num_vertices):
                    if dist[i, k] + dist[k, j] < dist[i, j]:
                        dist[i, j] = dist[i, k] + dist[k, j]
        return dist

    def get_diameter(self) -> float:
        """
        获取图的直径

        返回:
            图的直径
        """
        dist = self.get_shortest_paths()
        return np.max(dist[dist != np.inf])

    def get_radius(self) -> float:
        """
        获取图的半径

        返回:
            图的半径
        """
        dist = self.get_shortest_paths()
        return np.min(np.max(dist, axis=1))

    def get_centrality(self) -> List[float]:
        """
        获取每个节点的中心性

        返回:
            每个节点的中心性列表
        """
        dist = self.get_shortest_paths()
        return np.sum(dist, axis=1).tolist()

    def get_betweenness_centrality(self) -> List[float]:
        """
        计算每个节点的介数中心性

        返回:
            每个节点的介数中心性列表
        """
        dist = self.get_shortest_paths()
        betweenness = np.zeros(self.num_vertices)
        for s in range(self.num_vertices):
            for t in range(self.num_vertices):
                if s != t:
                    paths = self.find_paths(s, t)
                    num_paths = len(paths)
                    for path in paths:
                        for node in path[1:-1]:
                            betweenness[node] += 1 / num_paths
        return betweenness.tolist()

    def get_closeness_centrality(self) -> List[float]:
        """
        计算每个节点的紧度中心性

        返回:
            每个节点的紧度中心性列表
        """
        dist = self.get_shortest_paths()
        closeness = 1 / np.sum(dist, axis=1)
        return closeness.tolist()

def main():
    # 示例图（邻接矩阵表示）
    inf = float('inf')
    graph_matrix = np.array([
        [0, 2, 4, 0, 0],
        [0, 0, 1, 7, 0],
        [0, 0, 0, 0, 3],
        [0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0]
    ])
    
    graph = Graph(graph_matrix)

    print("节点: ", graph.get_nodes())
    print("边: ", graph.get_edges())
    print("节点度: ", graph.get_degrees())
    print("Hub节点: ", graph.get_hub_nodes())
    print("从节点0到节点4的所有路径: ", graph.find_paths(0, 4))
    print("是否存在回路: ", graph.has_cycle())
    print("是否连通: ", graph.is_connected())
    print("连通组件: ", graph.get_components())
    print("最短路径矩阵: \n", graph.get_shortest_paths())
    print("直径: ", graph.get_diameter())
    print("半径: ", graph.get_radius())
    print("中心性: ", graph.get_centrality())
    print("介数中心性: ", graph.get_betweenness_centrality())
    print("紧度中心性: ", graph.get_closeness_centrality())

if __name__ == "__main__":
    main()</code></pre>
  </div>
</body>
</html>
  