
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>直径、半径和中心性</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <p>直径、半径和中心性是图论中用于衡量图和节点重要性的关键指标。它们用于描述图的结构特性和节点在图中的重要性。下面是详细的对比和解释：</p>
<h3>直径（Diameter）</h3>
<h4>定义</h4>
<ul>
<li><strong>直径（Diameter）</strong>：图中任意两个节点之间最短路径的最大值。直径描述了图中最远的两个节点之间的距离。</li>
</ul>
<h4>计算方式</h4>
<ul>
<li><strong>Floyd-Warshall算法</strong>：计算所有节点对之间的最短路径，取这些最短路径中的最大值。</li>
<li><strong>BFS/DFS</strong>：对于无权图，可以从任意一个节点开始，进行两次BFS/DFS。第一次找到最远的节点，第二次从该节点开始找到最远的距离。</li>
</ul>
<h4>应用</h4>
<ul>
<li><strong>网络分析</strong>：衡量网络的最大通信延迟。</li>
<li><strong>社交网络</strong>：衡量网络中最远的社交距离。</li>
<li><strong>生物网络</strong>：衡量生物分子间的最长反应路径。</li>
</ul>
<h4>优缺点</h4>
<ul>
<li><strong>优点</strong>：提供了图中最长路径的信息，反映了图的最大尺度。</li>
<li><strong>缺点</strong>：计算复杂度较高，尤其是在大规模图中。</li>
</ul>
<h3>半径（Radius）</h3>
<h4>定义</h4>
<ul>
<li><strong>半径（Radius）</strong>：图中某个节点到所有其他节点的最短路径的最大值的最小值。即所有节点中离其他节点最短的最大距离。</li>
</ul>
<h4>计算方式</h4>
<ul>
<li><strong>Floyd-Warshall算法</strong>：计算所有节点对之间的最短路径，取每个节点的最短路径最大值，再取这些最大值中的最小值。</li>
</ul>
<h4>应用</h4>
<ul>
<li><strong>网络设计</strong>：衡量网络的中心节点。</li>
<li><strong>物流网络</strong>：衡量配送中心的位置。</li>
<li><strong>交通网络</strong>：衡量交通网络中的关键节点。</li>
</ul>
<h4>优缺点</h4>
<ul>
<li><strong>优点</strong>：提供了图中最中心节点的信息，反映了图的中心性。</li>
<li><strong>缺点</strong>：计算复杂度较高，尤其是在大规模图中。</li>
</ul>
<h3>中心性（Centrality）</h3>
<h4>定义</h4>
<ul>
<li><strong>中心性（Centrality）</strong>：衡量节点在图中的重要程度。常见的中心性指标包括度中心性、接近中心性和介数中心性。</li>
</ul>
<h4>度中心性（Degree Centrality）</h4>
<ul>
<li><strong>定义</strong>：节点度（连接数）表示节点的直接连接性。</li>
<li><strong>计算方式</strong>：节点的度数。</li>
</ul>
<h4>接近中心性（Closeness Centrality）</h4>
<ul>
<li><strong>定义</strong>：节点到其他所有节点的平均最短路径长度的倒数。接近中心性高的节点在图中处于中心位置。</li>
<li><strong>计算方式</strong>：
$$
\text{Closeness Centrality}(v) = \frac{1}{\sum_{u \in V} \text{Shortest Path}(v, u)}
$$</li>
</ul>
<h4>介数中心性（Betweenness Centrality）</h4>
<ul>
<li><strong>定义</strong>：节点在所有最短路径中作为中间节点的次数。介数中心性高的节点在图中起到重要的桥梁作用。</li>
<li><strong>计算方式</strong>：计算所有最短路径，统计每个节点作为中间节点的次数。</li>
</ul>
<h4>应用</h4>
<ul>
<li><strong>社交网络分析</strong>：识别关键人物和影响力大的用户。</li>
<li><strong>网络路由</strong>：优化数据包传输路径。</li>
<li><strong>组织管理</strong>：识别关键员工和团队协调者。</li>
</ul>
<h4>优缺点</h4>
<ul>
<li><strong>优点</strong>：提供了节点的重要性信息，有助于识别关键节点。</li>
<li><strong>缺点</strong>：计算复杂度较高，尤其是介数中心性。</li>
</ul>
<h3>详细对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>直径（Diameter）</th>
<th>半径（Radius）</th>
<th>中心性（Centrality）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>图中任意两个节点之间最短路径的最大值</td>
<td>图中某个节点到所有其他节点的最短路径最大值的最小值</td>
<td>衡量节点在图中的重要程度，包括度中心性、接近中心性和介数中心性</td>
</tr>
<tr>
<td><strong>计算方式</strong></td>
<td>Floyd-Warshall算法、BFS/DFS</td>
<td>Floyd-Warshall算法</td>
<td>度中心性、接近中心性、介数中心性</td>
</tr>
<tr>
<td><strong>应用</strong></td>
<td>网络分析、社交网络、生物网络</td>
<td>网络设计、物流网络、交通网络</td>
<td>社交网络分析、网络路由、组织管理</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>提供图中最长路径的信息</td>
<td>提供图中最中心节点的信息</td>
<td>提供节点的重要性信息</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>计算复杂度较高，尤其是在大规模图中</td>
<td>计算复杂度较高，尤其是在大规模图中</td>
<td>计算复杂度较高，尤其是介数中心性</td>
</tr>
</tbody>
</table>
<h3>示例代码</h3>
<p>以下是实现直径、半径和中心性的示例代码：</p>
<pre><code class="language-python">import numpy as np
from typing import List

class GraphMetrics:
    def __init__(self, adj_matrix: np.ndarray):
        ```
        初始化图对象和计算辅助数据结构

        参数:
            adj_matrix: 图的邻接矩阵表示
        ```
        self.adj_matrix = adj_matrix.astype(float)  # 确保邻接矩阵为浮点型
        self.num_vertices = adj_matrix.shape[0]

    def floyd_warshall(self) -&gt; np.ndarray:
        ```
        使用Floyd-Warshall算法计算所有节点对之间的最短路径

        返回:
            所有节点对之间的最短路径矩阵
        ```
        dist = np.copy(self.adj_matrix)
        dist[dist == 0] = np.inf
        np.fill_diagonal(dist, 0)
        for k in range(self.num_vertices):
            for i in range(self.num_vertices):
                for j in range(self.num_vertices):
                    if dist[i, k] + dist[k, j] &lt; dist[i, j]:
                        dist[i, j] = dist[i, k] + dist[k, j]
        return dist

    def get_diameter(self) -&gt; float:
        ```
        获取图的直径

        返回:
            图的直径
        ```
        dist = self.floyd_warshall()
        return np.max(dist[dist != np.inf])

    def get_radius(self) -&gt; float:
        ```
        获取图的半径

        返回:
            图的半径
        ```
        dist = self.floyd_warshall()
        return np.min(np.max(dist, axis=1))

    def get_closeness_centrality(self) -&gt; List[float]:
        ```
        获取每个节点的接近中心性

        返回:
            每个节点的接近中心性列表
        ```
        dist = self.floyd_warshall()
        closeness = 1 / np.sum(dist, axis=1)
        return closeness.tolist()

    def get_betweenness_centrality(self) -&gt; List[float]:
        ```
        计算每个节点的介数中心性

        返回:
            每个节点的介数中心性列表
        ```
        dist = self.floyd_warshall()
        betweenness = np.zeros(self.num_vertices)
        for s in range(self.num_vertices):
            for t in range(self.num_vertices):
                if s != t:
                    paths = self._find_all_shortest_paths(s, t, dist)
                    num_paths = len(paths)
                    for path in paths:
                        for node in path[1:-1]:
                            betweenness[node] += 1 / num_paths
        return betweenness.tolist()

    def _find_all_shortest_paths(self, start: int, end: int, dist: np.ndarray) -&gt; List[List[int]]:
        ```
        查找从起点到终点的所有最短路径

        参数:
            start: 起点
            end: 终点
            dist: 所有节点对之间的最短路径矩阵

        返回:
            所有最短路径的列表
        ```
        def dfs(current, path):
            if current == end:
                paths.append(path[:])
                return
            for neighbor in range(self.num_vertices):
                if dist[start, neighbor] + dist[neighbor, end] == dist[start, end] and neighbor not in path:
                    path.append(neighbor)
                    dfs(neighbor, path)
                    path.pop()

        paths = []
        dfs(start, [start])
        return paths

# 示例图（邻接矩阵表示）
graph_matrix = np.array([
    [0, 1, 0, 0, 1],
    [1, 0, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 1, 0, 1],
    [1, 0, 0, 1, 0]
], dtype=float)  # 确保邻接矩阵为浮点型

metrics = GraphMetrics(graph_matrix)
print(&quot;直径: &quot;, metrics.get_diameter())
print(&quot;半径: &quot;, metrics.get_radius())
print(&quot;接近中心性: &quot;, metrics.get_closeness_centrality())
print(&quot;介数中心性: &quot;, metrics

.get_betweenness_centrality())
</code></pre>
<h3>说明</h3>
<ol>
<li><strong>floyd_warshall方法</strong>：计算所有节点对之间的最短路径矩阵。</li>
<li><strong>get_diameter方法</strong>：通过最短路径矩阵计算图的直径。</li>
<li><strong>get_radius方法</strong>：通过最短路径矩阵计算图的半径。</li>
<li><strong>get_closeness_centrality方法</strong>：计算每个节点的接近中心性。</li>
<li><strong>get_betweenness_centrality方法</strong>：计算每个节点的介数中心性。</li>
<li><strong>_find_all_shortest_paths方法</strong>：辅助函数，用于查找从起点到终点的所有最短路径。</li>
</ol>
<h3>结论</h3>
<p>直径、半径和中心性是分析图结构和节点重要性的关键指标。直径描述图的最大尺度，半径描述图的中心节点，而中心性提供了节点的重要性信息。在实际应用中，这些指标可以结合使用，以全面分析图的结构和特性。</p>

    <h3>Python 文件</h3>
    <pre><code>对应的 Python 文件不存在。</code></pre>
  </div>
</body>
</html>
  