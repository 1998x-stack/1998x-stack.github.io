
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>1.4.2 运行 hello 程序</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>01_1.4.2_运行_hello_程序</h1>
<pre><code>Lecture: 01_计算机系统概览/1.4_处理器读取并解释存储在内存中的指令
Content: 01_1.4.2_运行_hello_程序
</code></pre>
<h3>详细分析：1.4.2 运行 hello 程序</h3>
<h4>1.4.2_运行_hello_程序</h4>
<p>运行一个简单的“hello”程序是理解计算机系统如何处理指令的基础。通过这个过程，我们可以了解从编写源代码到最终程序执行的全过程。下面将详细分析运行“hello”程序的每个步骤。</p>
<h4>源代码</h4>
<p>一个简单的“hello”程序的源代码通常如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<h4>编译过程</h4>
<p>编译过程将源代码转换为可执行的机器代码，通常包括以下几个步骤：</p>
<ol>
<li>
<p><strong>预处理</strong>：</p>
<ul>
<li><strong>宏替换</strong>：处理<code>#include</code>指令，将<code>stdio.h</code>的内容插入到源代码中。</li>
<li><strong>文件包含</strong>：插入标准库的内容。</li>
<li><strong>条件编译</strong>：根据条件编译指令选择性地编译代码片段。</li>
</ul>
</li>
<li>
<p><strong>编译</strong>：</p>
<ul>
<li><strong>词法分析</strong>：将源代码转换为一系列标记（tokens）。</li>
<li><strong>语法分析</strong>：将标记组织成语法树（syntax tree）。</li>
<li><strong>语义分析</strong>：检查程序的语义正确性。</li>
<li><strong>中间代码生成</strong>：将语法树转换为中间代码。</li>
<li><strong>优化</strong>：对中间代码进行优化，提高程序的执行效率。</li>
<li><strong>目标代码生成</strong>：将优化后的中间代码转换为目标机器的机器代码。</li>
</ul>
</li>
<li>
<p><strong>汇编</strong>：</p>
<ul>
<li><strong>汇编器</strong>：将目标代码转换为机器指令，并生成目标文件（.o文件）。</li>
</ul>
</li>
<li>
<p><strong>链接</strong>：</p>
<ul>
<li><strong>链接器</strong>：将多个目标文件和库文件链接成一个可执行文件。</li>
</ul>
</li>
</ol>
<h4>程序加载</h4>
<p>当用户运行“hello”程序时，操作系统将可执行文件加载到内存中，并准备好执行。</p>
<ol>
<li><strong>加载器（Loader）</strong>：
<ul>
<li><strong>分配内存</strong>：操作系统为程序分配内存空间。</li>
<li><strong>加载指令和数据</strong>：将可执行文件中的指令和数据加载到分配的内存空间中。</li>
<li><strong>设置堆栈</strong>：初始化堆栈，准备好函数调用和返回地址。</li>
<li><strong>设置入口点</strong>：将程序的入口点设置为main函数的地址。</li>
</ul>
</li>
</ol>
<h4>执行过程</h4>
<p>CPU开始执行程序，按照指令周期进行处理：</p>
<ol>
<li>
<p><strong>取指令（Fetch）</strong>：</p>
<ul>
<li>CPU从内存中取出下一条指令，并将其存储在指令寄存器中。</li>
</ul>
</li>
<li>
<p><strong>解码（Decode）</strong>：</p>
<ul>
<li>控制单元对取出的指令进行解码，确定指令的操作类型和操作数。</li>
</ul>
</li>
<li>
<p><strong>执行（Execute）</strong>：</p>
<ul>
<li>ALU根据解码结果执行相应的操作，处理数据。</li>
</ul>
</li>
<li>
<p><strong>存储（Store）</strong>：</p>
<ul>
<li>将处理结果存储在寄存器或主存储器中。</li>
</ul>
</li>
</ol>
<h4>“Hello, world!”输出</h4>
<p>在执行过程中，printf函数被调用，程序将“Hello, world!”输出到标准输出（通常是控制台）。</p>
<ol>
<li>
<p><strong>函数调用</strong>：</p>
<ul>
<li>当程序执行到printf函数调用时，控制单元将控制权转移到标准库中的printf函数。</li>
</ul>
</li>
<li>
<p><strong>参数传递</strong>：</p>
<ul>
<li>函数调用过程中，字符串“Hello, world!”作为参数传递给printf函数。</li>
</ul>
</li>
<li>
<p><strong>执行标准库函数</strong>：</p>
<ul>
<li>printf函数在标准库中实现，负责将字符串格式化并输出到标准输出。</li>
</ul>
</li>
<li>
<p><strong>系统调用</strong>：</p>
<ul>
<li>printf函数内部通过系统调用（如write）将数据输出到控制台。</li>
</ul>
</li>
</ol>
<h4>程序结束</h4>
<p>程序执行完main函数中的所有指令后，返回值为0，并调用操作系统的退出函数，释放资源。</p>
<ol>
<li>
<p><strong>返回值</strong>：</p>
<ul>
<li>main函数返回0，表示程序成功执行。</li>
</ul>
</li>
<li>
<p><strong>资源释放</strong>：</p>
<ul>
<li>操作系统回收程序占用的资源，包括内存和文件句柄。</li>
</ul>
</li>
<li>
<p><strong>程序退出</strong>：</p>
<ul>
<li>操作系统将控制权返回给终端或调用该程序的父进程。</li>
</ul>
</li>
</ol>
<h4>运行“hello”程序的整个过程总结</h4>
<ol>
<li><strong>编写源代码</strong>：程序员编写包含printf调用的简单C程序。</li>
<li><strong>编译和链接</strong>：编译器将源代码编译成目标代码，并通过链接生成可执行文件。</li>
<li><strong>加载程序</strong>：操作系统将可执行文件加载到内存中，并准备好执行环境。</li>
<li><strong>执行程序</strong>：CPU按照指令周期执行程序中的指令，最终调用printf函数输出“Hello, world!”。</li>
<li><strong>程序退出</strong>：程序执行完毕后，返回0，并释放所有资源。</li>
</ol>
<hr>
<h3>详细剖析 hello 程序的编译过程和执行过程</h3>
<h4>编译过程</h4>
<p>编译过程将源代码转换为可执行的机器代码，通常包括以下几个步骤：</p>
<ol>
<li>
<p><strong>预处理</strong>：</p>
<ul>
<li><strong>宏替换</strong>：处理<code>#include</code>指令，将<code>stdio.h</code>的内容插入到源代码中。</li>
<li><strong>文件包含</strong>：插入标准库的内容。</li>
<li><strong>条件编译</strong>：根据条件编译指令选择性地编译代码片段。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<p>在预处理阶段，<code>#include &lt;stdio.h&gt;</code>指令会被替换为标准输入输出库的实际内容。</p>
</li>
<li>
<p><strong>编译</strong>：</p>
<ul>
<li><strong>词法分析</strong>：将源代码转换为一系列标记（tokens），例如关键字、标识符、操作符等。</li>
<li><strong>语法分析</strong>：将标记组织成语法树（syntax tree），反映程序的结构和层次关系。</li>
<li><strong>语义分析</strong>：检查程序的语义正确性，确保数据类型和操作的合法性。</li>
<li><strong>中间代码生成</strong>：将语法树转换为中间代码，这是一种抽象的机器无关表示形式。</li>
<li><strong>优化</strong>：对中间代码进行优化，提高程序的执行效率。例如，消除冗余代码、常量折叠等。</li>
<li><strong>目标代码生成</strong>：将优化后的中间代码转换为目标机器的机器代码。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-c">// 中间代码生成
t1 = &quot;Hello, world!\n&quot;;
call printf, t1;
return 0;
</code></pre>
</li>
<li>
<p><strong>汇编</strong>：</p>
<ul>
<li><strong>汇编器</strong>：将目标代码转换为机器指令，并生成目标文件（.o文件）。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-assembly">_main:
    pushq   %rbp
    movq    %rsp, %rbp
    leaq    L_.str(%rip), %rdi
    call    _printf
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
</li>
<li>
<p><strong>链接</strong>：</p>
<ul>
<li><strong>链接器</strong>：将多个目标文件和库文件链接成一个可执行文件。链接器解析符号，处理外部引用，最终生成可执行文件。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-plaintext">ld -o hello hello.o /usr/lib/libc.a
</code></pre>
</li>
</ol>
<h4>执行过程</h4>
<p>当用户运行“hello”程序时，操作系统将可执行文件加载到内存中，并准备好执行。</p>
<ol>
<li>
<p><strong>加载器（Loader）</strong>：</p>
<ul>
<li><strong>分配内存</strong>：操作系统为程序分配内存空间。</li>
<li><strong>加载指令和数据</strong>：将可执行文件中的指令和数据加载到分配的内存空间中。</li>
<li><strong>设置堆栈</strong>：初始化堆栈，准备好函数调用和返回地址。</li>
<li><strong>设置入口点</strong>：将程序的入口点设置为main函数的地址。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-plaintext">地址空间：
0x00400000: hello程序的代码段
0x00600000: hello程序的数据段
0x7ff00000: 堆栈段
</code></pre>
</li>
<li>
<p><strong>执行过程</strong>：
CPU开始执行程序，按照指令周期进行处理：</p>
<ul>
<li>
<p><strong>取指令（Fetch）</strong>：</p>
<ul>
<li>CPU从内存中取出下一条指令，并将其存储在指令寄存器中。</li>
</ul>
</li>
<li>
<p><strong>解码（Decode）</strong>：</p>
<ul>
<li>控制单元对取出的指令进行解码，确定指令的操作类型和操作数。</li>
</ul>
</li>
<li>
<p><strong>执行（Execute）</strong>：</p>
<ul>
<li>ALU根据解码结果执行相应的操作，处理数据。</li>
</ul>
</li>
<li>
<p><strong>存储（Store）</strong>：</p>
<ul>
<li>将处理结果存储在寄存器或主存储器中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>函数调用（printf）</strong>：</p>
<ul>
<li>当程序执行到printf函数调用时，控制单元将控制权转移到标准库中的printf函数。</li>
<li>参数传递：字符串“Hello, world!”作为参数传递给printf函数。</li>
<li>执行标准库函数：printf函数在标准库中实现，负责将字符串格式化并输出到标准输出。</li>
<li>系统调用：printf函数内部通过系统调用（如write）将数据输出到控制台。</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-plaintext">printf调用栈：
main -&gt; printf -&gt; write
</code></pre>
</li>
<li>
<p><strong>程序结束</strong>：
程序执行完main函数中的所有指令后，返回值为0，并调用操作系统的退出函数，释放资源。</p>
<ul>
<li>
<p><strong>返回值</strong>：</p>
<ul>
<li>main函数返回0，表示程序成功执行。</li>
</ul>
</li>
<li>
<p><strong>资源释放</strong>：</p>
<ul>
<li>操作系统回收程序占用的资源，包括内存和文件句柄。</li>
</ul>
</li>
<li>
<p><strong>程序退出</strong>：</p>
<ul>
<li>操作系统将控制权返回给终端或调用该程序的父进程。</li>
</ul>
</li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="language-plaintext">退出码：0
</code></pre>
</li>
</ol>
<h4>运行“hello”程序的整个过程总结</h4>
<ol>
<li><strong>编写源代码</strong>：程序员编写包含printf调用的简单C程序。</li>
<li><strong>编译和链接</strong>：编译器将源代码编译成目标代码，并通过链接生成可执行文件。</li>
<li><strong>加载程序</strong>：操作系统将可执行文件加载到内存中，并准备好执行环境。</li>
<li><strong>执行程序</strong>：CPU按照指令周期执行程序中的指令，最终调用printf函数输出“Hello, world!”。</li>
<li><strong>程序退出</strong>：程序执行完毕后，返回0，并释放所有资源。</li>
</ol>

    <h3>Python 文件</h3>
    <pre><code># 01_1.4.2_运行_hello_程序

"""
Lecture: 01_计算机系统概览/1.4_处理器读取并解释存储在内存中的指令
Content: 01_1.4.2_运行_hello_程序
"""

</code></pre>
  </div>
</body>
</html>
  