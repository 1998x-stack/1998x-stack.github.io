# 02_3.11.3_浮点算术运算

"""
Lecture: 03_程序的机器级表示/3.11_浮点代码
Content: 02_3.11.3_浮点算术运算
"""

### 3.11.3 浮点算术运算

#### 概述
浮点算术运算在计算机程序中扮演着重要角色，特别是在科学计算和图形处理等领域。x86-64架构提供了一组强大的浮点算术指令，支持单精度和双精度浮点数运算。这些指令利用XMM寄存器进行高效计算，支持加法、减法、乘法、除法等操作。

#### 浮点算术指令集
以下是一些常见的浮点算术指令及其功能：

- **加法（Addition）**
  - `vaddss`：单精度浮点数加法。
  - `vaddsd`：双精度浮点数加法。

- **减法（Subtraction）**
  - `vsubss`：单精度浮点数减法。
  - `vsubsd`：双精度浮点数减法。

- **乘法（Multiplication）**
  - `vmulss`：单精度浮点数乘法。
  - `vmulsd`：双精度浮点数乘法。

- **除法（Division）**
  - `vdivss`：单精度浮点数除法。
  - `vdivsd`：双精度浮点数除法。

- **平方根（Square Root）**
  - `vsqrtss`：单精度浮点数平方根。
  - `vsqrtsd`：双精度浮点数平方根。

这些指令可以在XMM寄存器之间执行操作，或在XMM寄存器和内存之间进行操作。

#### 示例分析
以下示例展示了如何使用这些浮点算术指令执行基本的浮点运算：

```assembly
section .data
    a dq 3.14
    b dq 2.71
    result dq 0.0

section .text
    global _start

_start:
    ; 加载浮点数到XMM寄存器
    movsd xmm0, [a]
    movsd xmm1, [b]

    ; 执行浮点加法
    addsd xmm0, xmm1

    ; 将结果存储到内存
    movsd [result], xmm0

    ; 退出程序
    mov eax, 60                ; 系统调用号 (sys_exit)
    xor edi, edi               ; 状态码 0
    syscall
```

在这个示例中，`movsd`指令用于加载和存储双精度浮点数，`addsd`指令用于执行浮点加法。

#### 深入分析
##### 精度和舍入
浮点数运算的精度和舍入方式是理解浮点算术运算的关键。IEEE 754标准定义了多种舍入模式，包括向偶数舍入（round to even）、向零舍入（round towards zero）、向正无穷大舍入（round towards +∞）和向负无穷大舍入（round towards -∞）。默认的舍入模式是向偶数舍入，这种模式能够最小化舍入误差。

例如，考虑以下两种舍入方式：

- **向偶数舍入**：当两个可能的结果距离原始值等距离时，选择结果的最低有效位为偶数的那个。例如，1.5舍入为2.0，而2.5也舍入为2.0。
- **向零舍入**：直接舍去小数部分。例如，1.7舍入为1.0，而-1.7舍入为-1.0。

##### 算术运算的非结合性
浮点数运算不满足结合律，这意味着计算顺序会影响结果。例如：

```assembly
movsd xmm0, [a]        ; xmm0 = 3.14
movsd xmm1, [b]        ; xmm1 = 2.71
addsd xmm0, xmm1       ; xmm0 = 5.85
movsd xmm1, [c]        ; xmm1 = 1.41
subsd xmm0, xmm1       ; xmm0 = 4.44
```

如果我们改变运算顺序，结果可能会不同，这在科学计算中尤其需要注意。

##### 优化和性能
在编写高性能代码时，理解和利用寄存器的特点非常重要。以下是一些优化技巧：

- **减少内存访问**：尽量在寄存器之间进行操作，减少内存读取和写入的次数。
- **并行计算**：利用向量化指令（如AVX）进行并行计算，提高处理效率。

例如，以下代码使用AVX指令进行并行加法：

```assembly
section .data
    a dq 3.14, 2.71
    b dq 1.41, 1.73
    result dq 0.0, 0.0

section .text
    global _start

_start:
    ; 加载浮点数组到YMM寄存器
    vmovapd ymm0, [a]
    vmovapd ymm1, [b]

    ; 执行并行浮点加法
    vaddpd ymm0, ymm0, ymm1

    ; 将结果存储到内存
    vmovapd [result], ymm0

    ; 退出程序
    mov eax, 60                ; 系统调用号 (sys_exit)
    xor edi, edi               ; 状态码 0
    syscall
```

在这个示例中，`vmovapd`和`vaddpd`指令用于并行处理两个双精度浮点数，显著提高了计算效率。

#### 总结
浮点算术运算在x86-64架构中有着广泛的应用，通过理解和掌握这些指令及其特点，可以编写出高效、准确的浮点数处理代码。优化浮点运算时，需要特别注意精度和舍入问题，并尽量利用寄存器和并行计算能力来提高性能。

### 引用


---

### 代码详细解释及寄存器搭配

#### 概述
这段汇编代码演示了如何使用 AVX 指令集进行并行浮点运算。代码将两个浮点数数组加载到 YMM 寄存器中，执行并行加法运算，并将结果存储回内存。代码最后通过系统调用退出程序。

#### 数据段
在数据段中定义了两个浮点数组 `a` 和 `b`，以及存储结果的数组 `result`：
```assembly
section .data
    a dq 3.14, 2.71      ; 定义一个包含两个双精度浮点数的数组
    b dq 1.41, 1.73      ; 定义另一个包含两个双精度浮点数的数组
    result dq 0.0, 0.0   ; 定义一个用于存储结果的数组，初始值为0.0
```

#### 代码段
在代码段中定义了程序的主入口 `_start`，并使用 AVX 指令进行浮点运算：
```assembly
section .text
    global _start

_start:
    ; 加载浮点数组到YMM寄存器
    vmovapd ymm0, [a]    ; 将内存中数组 a 的内容加载到 YMM0 寄存器中
    vmovapd ymm1, [b]    ; 将内存中数组 b 的内容加载到 YMM1 寄存器中

    ; 执行并行浮点加法
    vaddpd ymm0, ymm0, ymm1  ; 将 YMM0 和 YMM1 中的浮点数相加，并将结果存储在 YMM0 中

    ; 将结果存储到内存
    vmovapd [result], ymm0   ; 将 YMM0 寄存器中的结果存储回内存中的 result 数组

    ; 退出程序
    mov eax, 60              ; 系统调用号 (sys_exit)
    xor edi, edi             ; 状态码 0
    syscall                  ; 触发系统调用退出程序
```

#### 指令详解
- `vmovapd ymm0, [a]`：将内存地址 `[a]` 处的两个双精度浮点数加载到 `YMM0` 寄存器中。`vmovapd` 指令用于加载或存储对齐的打包双精度浮点数。
- `vmovapd ymm1, [b]`：将内存地址 `[b]` 处的两个双精度浮点数加载到 `YMM1` 寄存器中。
- `vaddpd ymm0, ymm0, ymm1`：将 `YMM0` 和 `YMM1` 寄存器中的浮点数逐元素相加，结果存储在 `YMM0` 中。`vaddpd` 指令用于执行对齐的打包双精度浮点数加法。
- `vmovapd [result], ymm0`：将 `YMM0` 寄存器中的结果存储回内存地址 `[result]` 处。

#### 寄存器搭配
在这段代码中，主要使用了以下寄存器：
- **YMM0**：用于存储数组 `a` 的值，以及最终的加法结果。
- **YMM1**：用于存储数组 `b` 的值。

此外，以下寄存器用于系统调用退出程序：
- **EAX**：存储系统调用号 `60`，表示 `sys_exit` 系统调用。
- **EDI**：存储退出状态码 `0`。

#### 执行流程
1. **加载数据**：使用 `vmovapd` 指令将两个浮点数组加载到 YMM 寄存器中。
2. **浮点加法**：使用 `vaddpd` 指令对两个寄存器中的浮点数执行并行加法运算。
3. **存储结果**：使用 `vmovapd` 指令将运算结果存储回内存。
4. **退出程序**：通过系统调用 `sys_exit` 退出程序。

### 总结
这段代码展示了如何使用 AVX 指令进行高效的并行浮点运算。通过利用 YMM 寄存器，可以同时处理多个浮点数，大大提高了计算效率。理解这些指令和寄存器的搭配，对于编写高性能的汇编代码非常重要。