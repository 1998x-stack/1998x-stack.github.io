
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>5.4.1 基本介绍</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>00_5.4.1_基本介绍</h1>
<pre><code>Lecture: 5._掌握向量化回测/5.4_基于均值回归的策略
Content: 00_5.4.1_基本介绍
</code></pre>
<h3>详细分析 5.4.1 基本介绍</h3>
<h4>1. 引言</h4>
<p>在金融市场中，基于均值回归的策略（Mean Reversion Strategy）是一种常见的交易策略。其基本思想是资产价格在偏离其均值或趋势水平后，会倾向于回归到该均值或趋势水平。均值回归策略假设价格的极端波动是暂时的，价格会随着时间的推移回到正常水平。因此，当资产价格偏离均值时，可以采取相应的买入或卖出操作，以期在价格回归均值时获利。</p>
<h4>2. 均值回归策略的基本概念</h4>
<p>均值回归策略通常基于以下几个要素：</p>
<ul>
<li><strong>均值</strong>：常用的均值包括简单移动平均线（SMA）和指数移动平均线（EMA）。</li>
<li><strong>阈值</strong>：当价格偏离均值达到一定程度（阈值）时，触发买入或卖出信号。</li>
<li><strong>回归周期</strong>：价格回归到均值所需的时间周期。</li>
</ul>
<h4>3. 均值回归策略的优势和劣势</h4>
<p><strong>优势</strong>：</p>
<ol>
<li><strong>直观易懂</strong>：均值回归策略的逻辑简单，易于理解和实现。</li>
<li><strong>风险管理</strong>：通过设置合适的阈值，可以有效管理风险，避免过度交易。</li>
<li><strong>市场适应性强</strong>：适用于各种市场和资产类别，包括股票、外汇、大宗商品等。</li>
</ol>
<p><strong>劣势</strong>：</p>
<ol>
<li><strong>假设前提</strong>：均值回归策略假设价格会回归均值，但在趋势市场中可能会失效。</li>
<li><strong>滞后性</strong>：均值计算基于历史数据，可能无法及时反映市场的最新变化。</li>
<li><strong>高交易成本</strong>：频繁的买卖操作会增加交易成本，削弱策略的实际收益。</li>
</ol>
<h4>4. 均值回归策略的实现步骤</h4>
<ol>
<li><strong>数据获取</strong>：获取目标资产的历史价格数据，计算移动平均线和价格偏离度。</li>
<li><strong>阈值设定</strong>：设定价格偏离均值的阈值，当价格偏离超过该阈值时触发交易信号。</li>
<li><strong>信号生成</strong>：根据价格相对于均值的位置生成买入或卖出信号。</li>
<li><strong>交易执行</strong>：根据生成的交易信号执行买入或卖出操作。</li>
<li><strong>绩效评估</strong>：对策略的表现进行评估，计算总收益、最大回撤、夏普比率等指标。</li>
</ol>
<h4>5. 均值回归策略的改进和优化</h4>
<ol>
<li><strong>动态阈值调整</strong>：根据市场波动性动态调整阈值，提高策略的灵活性和适应性。</li>
<li><strong>结合其他技术指标</strong>：结合动量指标（如RSI）和布林带（Bollinger Bands）等，提高策略的准确性和稳健性。</li>
<li><strong>机器学习方法</strong>：利用机器学习算法优化均值回归策略，如通过特征选择和模型训练提高策略的预测能力。</li>
<li><strong>风险管理</strong>：设置止损和止盈水平，以控制风险和保护利润。</li>
</ol>
<h4>6. 实际应用案例</h4>
<p>以下是一个基于均值回归策略的实际应用案例：</p>
<ol>
<li><strong>数据获取</strong>：从Yahoo Finance获取某只股票的历史价格数据。</li>
<li><strong>均值计算</strong>：计算该股票过去30天的简单移动平均线（SMA）。</li>
<li><strong>信号生成</strong>：当价格偏离SMA超过设定的阈值时，生成买入或卖出信号。</li>
<li><strong>交易执行</strong>：根据信号进行买入或卖出操作，计算每日的收益。</li>
<li><strong>绩效评估</strong>：计算策略在一年的时间内的总收益、最大回撤和夏普比率。</li>
</ol>
<h4>7. 结论</h4>
<p>均值回归策略是一种基于价格回归均值假设的交易策略，因其直观易懂且风险管理能力强而受到广泛欢迎。然而，均值回归策略也存在假设前提和高交易成本等挑战。通过动态调整阈值、结合其他技术指标和引入机器学习方法，均值回归策略可以进一步优化和改进，以在不同的市场环境中实现更好的表现。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_5.4.1_基本介绍

"""
Lecture: 5._掌握向量化回测/5.4_基于均值回归的策略
Content: 00_5.4.1_基本介绍
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
import logging
from typing import List, Dict

class MeanReversionTradingStrategy:
    def __init__(self, ticker: str, window: int, rsi_window: int, bollinger_window: int, threshold: float, stop_loss: float = None, take_profit: float = None):
        """
        初始化交易策略类
        :param ticker: 股票代码
        :param window: 均值回归的时间窗口
        :param rsi_window: RSI的时间窗口
        :param bollinger_window: 布林带的时间窗口
        :param threshold: 均值回归阈值
        :param stop_loss: 止损百分比
        :param take_profit: 止盈百分比
        """
        self.ticker = ticker
        self.window = window
        self.rsi_window = rsi_window
        self.bollinger_window = bollinger_window
        self.threshold = threshold
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.data = None

        # 配置日志
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    def fetch_data(self, start_date: str, end_date: str) -> pd.DataFrame:
        """
        获取金融数据
        :param start_date: 起始日期
        :param end_date: 结束日期
        :return: 包含金融数据的DataFrame
        """
        logging.info(f"Fetching data for {self.ticker} from {start_date} to {end_date}")
        data = yf.download(self.ticker, start=start_date, end=end_date)
        data.reset_index(inplace=True)
        self.data = data[['Date', 'Close']]
        logging.info(f"数据获取成功: {self.data.head()}")
        return self.data

    def calculate_indicators(self) -> pd.DataFrame:
        """
        计算技术指标，包括SMA、RSI和布林带
        :return: 包含技术指标数据的DataFrame
        """
        self.data['SMA'] = self.data['Close'].rolling(window=self.window).mean()
        self.data['RSI'] = self.calculate_rsi(self.data['Close'], self.rsi_window)
        self.data['Bollinger_Upper'] = self.data['Close'].rolling(window=self.bollinger_window).mean() + 2 * self.data['Close'].rolling(window=self.bollinger_window).std()
        self.data['Bollinger_Lower'] = self.data['Close'].rolling(window=self.bollinger_window).mean() - 2 * self.data['Close'].rolling(window=self.bollinger_window).std()
        logging.info(f"技术指标计算完成: {self.data.head()}")
        return self.data

    @staticmethod
    def calculate_rsi(data: pd.Series, window: int) -> pd.Series:
        """
        计算RSI指标
        :param data: 价格数据
        :param window: RSI的时间窗口
        :return: RSI指标数据
        """
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def generate_signals(self) -> pd.DataFrame:
        """
        生成交易信号
        :return: 包含交易信号的DataFrame
        """
        self.data['signal'] = 0
        buy_condition = (self.data['Close'] < self.data['Bollinger_Lower']) & (self.data['RSI'] < 30)
        sell_condition = (self.data['Close'] > self.data['Bollinger_Upper']) & (self.data['RSI'] > 70)
        self.data['signal'][buy_condition] = 1
        self.data['signal'][sell_condition] = -1
        self.data['position'] = self.data['signal'].diff()
        logging.info(f"交易信号生成完成: {self.data.head()}")
        return self.data

    def apply_stop_loss_take_profit(self) -> pd.DataFrame:
        """
        应用止损和止盈机制
        :return: 更新后的DataFrame
        """
        if self.stop_loss is not None or self.take_profit is not None:
            self.data['cumulative_return'] = (1 + self.data['strategy_return']).cumprod()
            self.data['peak'] = self.data['cumulative_return'].cummax()
            if self.stop_loss is not None:
                self.data['drawdown'] = self.data['peak'] - self.data['cumulative_return']
                self.data['stop_loss'] = np.where(self.data['drawdown'] / self.data['peak'] >= self.stop_loss, 1, 0)
            if self.take_profit is not None:
                self.data['take_profit'] = np.where(self.data['cumulative_return'] / self.data['peak'] - 1 >= self.take_profit, 1, 0)
            self.data['exit_signal'] = self.data[['stop_loss', 'take_profit']].max(axis=1)
            self.data['signal'] = np.where(self.data['exit_signal'] == 1, 0, self.data['signal'])
        return self.data

    def backtest(self, initial_capital: float) -> Dict[str, float]:
        """
        回测交易策略
        :param initial_capital: 初始资金
        :return: 回测结果，包括总收益和最大回撤
        """
        self.data['daily_return'] = self.data['Close'].pct_change()
        self.data['strategy_return'] = self.data['daily_return'] * self.data['signal'].shift(1)
        self.apply_stop_loss_take_profit()
        self.data['cumulative_return'] = (1 + self.data['strategy_return']).cumprod()
        self.data['cumulative_return'].fillna(1, inplace=True)
        total_return = self.data['cumulative_return'].iloc[-1] * initial_capital
        max_drawdown = self.calculate_max_drawdown(self.data['cumulative_return'])
        logging.info(f"回测完成: 总收益={total_return}, 最大回撤={max_drawdown}")
        return {'total_return': total_return, 'max_drawdown': max_drawdown}

    @staticmethod
    def calculate_max_drawdown(cumulative_returns: pd.Series) -> float:
        """
        计算最大回撤
        :param cumulative_returns: 累计收益率序列
        :return: 最大回撤值
        """
        roll_max = cumulative_returns.cummax()
        drawdown = roll_max - cumulative_returns
        max_drawdown = drawdown.max() / roll_max.max()
        logging.info(f"最大回撤计算完成: {max_drawdown}")
        return max_drawdown

    def plot(self):
        """
        绘制交易策略图表
        """
        plt.figure(figsize=(14, 7))
        plt.plot(self.data['Date'], self.data['Close'], label='Close Price')
        plt.plot(self.data['Date'], self.data['SMA'], label='SMA')
        plt.plot(self.data['Date'], self.data['Bollinger_Upper'], label='Bollinger Upper')
        plt.plot(self.data['Date'], self.data['Bollinger_Lower'], label='Bollinger Lower')
        plt.plot(self.data.loc[self.data['position'] == 1, 'Date'],
                 self.data['Close'][self.data['position'] == 1], '^', markersize=10, color='g', lw=0,
                 label='Buy Signal')
        plt.plot(self.data.loc[self.data['position'] == -1, 'Date'],
                 self.data['Close'][self.data['position'] == -1], 'v', markersize=10, color='r', lw=0,
                 label='Sell Signal')
        plt.title(f'{self.ticker} - Mean Reversion Trading Strategy')
        plt.xlabel('Date')
        plt.ylabel('Price')
        plt.legend()
        plt.grid()
        plt.show()


if __name__ == "__main__":
    strategy = MeanReversionTradingStrategy(ticker='AAPL', window=30, rsi_window=14, bollinger_window=20, threshold=0.05, stop_loss=0.1, take_profit=0.2)
    strategy.fetch_data(start_date='2022-01-01', end_date='2023-01-01')
    strategy.calculate_indicators()
    strategy.generate_signals()
    result = strategy.backtest(initial_capital=10000)
    strategy.plot()
    print(f"回测结果: {result}")
</code></pre>
  </div>
</body>
</html>
  