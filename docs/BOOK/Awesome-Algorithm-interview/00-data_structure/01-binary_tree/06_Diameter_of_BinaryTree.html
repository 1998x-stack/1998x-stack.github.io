
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>Diameter of BinaryTree</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <blockquote>
<p>二叉树的直径</p>
</blockquote>
<p>二叉树的直径（Diameter of a Binary Tree）是指二叉树中任意两个节点之间路径上的节点数的最大值。这个路径可能通过根节点，也可能不通过根节点。计算二叉树的直径的常用方法是通过递归，计算每个节点的左右子树的深度，并更新直径的最大值。</p>
<h3>算法步骤</h3>
<ol>
<li>定义一个全局变量 <code>max_diameter</code>，用来存储当前计算出的最大直径。</li>
<li>定义一个递归函数 <code>depth(node)</code>，该函数返回以 <code>node</code> 为根节点的子树的深度，并在计算过程中更新 <code>max_diameter</code>。</li>
<li>在 <code>depth(node)</code> 函数中：
<ul>
<li>如果节点 <code>node</code> 为空，返回深度 0。</li>
<li>递归计算左子树的深度 <code>left_depth</code> 和右子树的深度 <code>right_depth</code>。</li>
<li>更新 <code>max_diameter</code> 为 <code>left_depth + right_depth</code> 和当前 <code>max_diameter</code> 的较大值。</li>
<li>返回当前节点的深度，即 <code>max(left_depth, right_depth) + 1</code>。</li>
</ul>
</li>
<li>调用 <code>depth(root)</code> 函数开始计算。</li>
</ol>
<h3>代码实现</h3>
<p>以下是 Python 实现计算二叉树直径的代码：</p>
<pre><code class="language-python">class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def diameter_of_binary_tree(root):
    def depth(node):
        nonlocal max_diameter
        if not node:
            return 0
        left_depth = depth(node.left)
        right_depth = depth(node.right)
        max_diameter = max(max_diameter, left_depth + right_depth)
        return max(left_depth, right_depth) + 1
    
    max_diameter = 0
    depth(root)
    return max_diameter

# 示例使用
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(diameter_of_binary_tree(root))  # 输出: 3
</code></pre>
<h3>解释</h3>
<ul>
<li>
<p><strong><code>depth(node)</code></strong>：递归函数，返回以 <code>node</code> 为根节点的子树的深度。</p>
<ul>
<li>如果 <code>node</code> 为空，返回深度 0。</li>
<li>计算左子树和右子树的深度。</li>
<li>更新 <code>max_diameter</code> 为当前节点的左右子树深度之和与 <code>max_diameter</code> 的较大值。</li>
<li>返回当前节点的深度，即 <code>max(left_depth, right_depth) + 1</code>。</li>
</ul>
</li>
<li>
<p><strong><code>diameter_of_binary_tree(root)</code></strong>：主函数，初始化 <code>max_diameter</code> 并调用 <code>depth(root)</code> 开始计算。</p>
</li>
</ul>
<h3>复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：O(N)，其中 N 是二叉树中的节点数。每个节点只被访问一次。</li>
<li><strong>空间复杂度</strong>：O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为树的高度。</li>
</ul>
<h3>参考文献</h3>
<ol>
<li>
<p><strong>LeetCode Problem - Diameter of Binary Tree</strong>:</p>
<ul>
<li>提供了二叉树直径问题的详细描述和解决方案。</li>
<li><a href="https://leetcode.com/problems/diameter-of-binary-tree/">LeetCode链接</a></li>
</ul>
</li>
<li>
<p><strong>GeeksforGeeks - Diameter of a Binary Tree</strong>:</p>
<ul>
<li>详细介绍了如何计算二叉树的直径，并提供了多种实现方法。</li>
<li><a href="https://www.geeksforgeeks.org/diameter-of-a-binary-tree/">GeeksforGeeks链接</a></li>
</ul>
</li>
</ol>

    <h3>Python 文件</h3>
    <pre><code>对应的 Python 文件不存在。</code></pre>
  </div>
</body>
</html>
  