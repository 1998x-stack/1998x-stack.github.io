
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>05-majority element</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <blockquote>
<p>查找出现超过一半的数字</p>
</blockquote>
<p>查找数组中出现次数超过一半的数字（多数元素）是一类经典问题，可以使用多种算法来解决，其中最常见和高效的是摩尔投票算法（Boyer-Moore Voting Algorithm）。</p>
<h3>方法：摩尔投票算法</h3>
<p>摩尔投票算法是一种线性时间复杂度 $O(n)$ 和常数空间复杂度 $O(1)$ 的算法，适用于寻找多数元素。该算法基于以下原理：如果一个元素出现次数超过数组长度的一半，那么它一定会在数组的中位数位置出现。</p>
<h4>算法步骤</h4>
<ol>
<li>
<p><strong>初始化候选人和计数器</strong>：</p>
<ul>
<li>设置一个候选人变量 <code>candidate</code>，初始化为空。</li>
<li>设置一个计数器 <code>count</code>，初始化为0。</li>
</ul>
</li>
<li>
<p><strong>第一次遍历数组</strong>：</p>
<ul>
<li>遍历数组中的每个元素 <code>num</code>：
<ul>
<li>如果 <code>count</code> 为0，则将 <code>candidate</code> 设置为当前元素 <code>num</code>。</li>
<li>如果 <code>num</code> 与 <code>candidate</code> 相同，则将 <code>count</code> 增加1。</li>
<li>如果 <code>num</code> 与 <code>candidate</code> 不同，则将 <code>count</code> 减少1。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>第二次遍历数组（可选）</strong>：</p>
<ul>
<li>确认 <code>candidate</code> 是多数元素：
<ul>
<li>遍历数组，计算 <code>candidate</code> 的实际出现次数，确保其确实超过数组长度的一半。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>代码实现</h3>
<pre><code class="language-python">def majority_element(nums):
    # 第一遍遍历寻找候选人
    candidate = None
    count = 0
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    # 第二遍遍历确认候选人
    count = 0
    for num in nums:
        if num == candidate:
            count += 1

    if count &gt; len(nums) // 2:
        return candidate
    else:
        return None

# 示例使用
nums = [2, 2, 1, 1, 1, 2, 2]
print(majority_element(nums))  # 输出: 2
</code></pre>
<h3>解释</h3>
<ol>
<li>
<p><strong>第一次遍历</strong>：</p>
<ul>
<li>初始化 <code>candidate</code> 和 <code>count</code>。</li>
<li>遍历数组，当 <code>count</code> 为0时更新 <code>candidate</code>。</li>
<li>如果当前元素与 <code>candidate</code> 相同，增加 <code>count</code>；否则，减少 <code>count</code>。</li>
</ul>
</li>
<li>
<p><strong>第二次遍历（可选）</strong>：</p>
<ul>
<li>确认 <code>candidate</code> 是否确实为多数元素，遍历数组计算 <code>candidate</code> 的实际出现次数。</li>
<li>如果 <code>candidate</code> 的出现次数超过数组长度的一半，返回 <code>candidate</code>；否则，返回 <code>None</code>。</li>
</ul>
</li>
</ol>
<h3>优点和缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，只需两次遍历数组。</li>
<li><strong>空间复杂度</strong>：$O(1)$，只使用常数额外空间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要保证输入数组中确实存在多数元素，否则需要进行额外的确认步骤。</li>
</ul>
<h3>参考文献</h3>
<ol>
<li>
<p><strong>GeeksforGeeks - Majority Element</strong>：</p>
<ul>
<li>提供了摩尔投票算法的详细解释和代码实现。</li>
<li><a href="https://www.geeksforgeeks.org/majority-element/">链接</a></li>
</ul>
</li>
<li>
<p><strong>LeetCode Problem - Majority Element</strong>：</p>
<ul>
<li>提供了多数元素问题的详细描述和解决方案。</li>
<li><a href="https://leetcode.com/problems/majority-element/">LeetCode链接</a></li>
</ul>
</li>
</ol>

    <h3>Python 文件</h3>
    <pre><code>对应的 Python 文件不存在。</code></pre>
  </div>
</body>
</html>
  