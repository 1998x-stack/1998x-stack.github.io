
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>02-duplicate numbers</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <blockquote>
<p>重复数字的排列，重复数字的组合</p>
</blockquote>
<h3>含重复数字的排列</h3>
<p>含重复数字的排列问题是指给定一个包含重复数字的序列，生成所有可能的排列，并确保排列的结果中没有重复的排列。可以通过回溯算法来实现，并在过程中使用一个集合来避免重复。</p>
<h4>代码实现</h4>
<pre><code class="language-python">def permute_unique(nums):
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        seen = set()
        for i in range(start, len(nums)):
            if nums[i] not in seen:
                seen.add(nums[i])
                nums[start], nums[i] = nums[i], nums[start]
                backtrack(start + 1)
                nums[start], nums[i] = nums[i], nums[start]
    
    result = []
    nums.sort()
    backtrack(0)
    return result

# 示例使用
nums = [1, 1, 2]
permutations = permute_unique(nums)
print(permutations)  # 输出: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]
</code></pre>
<h3>含重复数字的组合</h3>
<p>含重复数字的组合问题是指给定一个包含重复数字的序列，生成所有可能的组合，并确保组合的结果中没有重复的组合。可以通过回溯算法来实现，并在过程中避免选择相同的数字。</p>
<h4>代码实现</h4>
<pre><code class="language-python">def combine_unique(nums, k):
    def backtrack(start, comb):
        if len(comb) == k:
            result.append(comb[:])
            return
        for i in range(start, len(nums)):
            if i &gt; start and nums[i] == nums[i - 1]:
                continue
            comb.append(nums[i])
            backtrack(i + 1, comb)
            comb.pop()
    
    result = []
    nums.sort()
    backtrack(0, [])
    return result

# 示例使用
nums = [1, 2, 2]
k = 2
combinations = combine_unique(nums, k)
print(combinations)  # 输出: [[1, 2], [2, 2]]
</code></pre>
<h3>总结</h3>
<ul>
<li><strong>含重复数字的排列</strong>：通过回溯和集合避免重复生成所有可能的排列。</li>
<li><strong>含重复数字的组合</strong>：通过回溯和剪枝避免重复生成所有可能的组合。</li>
</ul>

    <h3>Python 文件</h3>
    <pre><code>对应的 Python 文件不存在。</code></pre>
  </div>
</body>
</html>
  