# 01_2.3.2_快速排序性能

"""
Lecture: 02._排序和顺序统计/2.3_快速排序
Content: 01_2.3.2_快速排序性能
"""

### 2.3.2 快速排序性能

快速排序（Quicksort）是一种高效的排序算法，其性能取决于每次分区（partitioning）的平衡性，而分区的平衡性又取决于选择的基准元素（pivot）。在详细分析快速排序的性能时，我们需要考虑最坏情况、最好情况和平均情况。

#### 最坏情况

在最坏情况下，快速排序的时间复杂度为 $O(n^2)$。这种情况发生在每次分区时，基准元素总是选择了子数组的最小或最大元素，使得每次分区都极不平衡。例如，当输入数组已经有序或逆序时，会出现这种情况。

**最坏情况分析**：
- 每次分区的时间复杂度为 $O(n)$，因为需要遍历整个子数组来找到基准元素的位置。
- 由于每次分区后的一个子数组为空，另一个子数组包含 $n-1$ 个元素，因此递归调用的深度为 $n$。
- 总时间复杂度为 $T(n) = T(n-1) + O(n) = O(n^2)$。

#### 最好情况

在最好情况下，每次分区的结果是两个大小大致相等的子数组，这样快速排序的递归树深度为 $\log n$，每层的工作量为 $O(n)$，总时间复杂度为 $O(n \log n)$。

**最好情况分析**：
- 每次分区的时间复杂度仍然是 $O(n)$。
- 分区后的两个子数组大小为 $\lfloor n/2 \rfloor$ 和 $\lceil n/2 \rceil$，递归树的深度为 $\log n$。
- 总时间复杂度为 $T(n) = 2T(n/2) + O(n)$，根据主定理，解决该递归式得到 $T(n) = O(n \log n)$。

#### 平均情况

平均情况下，快速排序的性能也接近于 $O(n \log n)$。在随机排列的输入数组上，快速排序的分区结果大部分情况下都是相对平衡的。

**平均情况分析**：
- 假设每次分区基准元素将数组大致均匀地分成两个部分，则递归树的深度为 $\log n$。
- 每层的总工作量为 $O(n)$，因为每个元素在每层只被比较一次。
- 总时间复杂度为 $T(n) = 2T(n/2) + O(n)$，根据主定理，得到 $T(n) = O(n \log n)$。

#### 分区的影响

快速排序的关键在于分区操作（partitioning）。分区的平衡性直接影响算法的性能。以下是不同分区平衡性对性能的影响：
- **极不平衡分区**：每次分区产生一个非常小的子数组和一个几乎与原数组一样大的子数组。这种情况下，递归深度接近 $n$，总时间复杂度为 $O(n^2)$。
- **均衡分区**：每次分区产生两个大小大致相等的子数组。这种情况下，递归深度为 $\log n$，总时间复杂度为 $O(n \log n)$。
- **常数比例分区**：每次分区产生的子数组按固定比例（例如9:1）分割，即使看似不平衡，递归深度仍为 $\log n$，总时间复杂度仍为 $O(n \log n)$。

#### 空间复杂度

快速排序的空间复杂度主要由递归调用栈的深度决定。在最坏情况下，递归调用栈的深度为 $O(n)$；在平均情况下，递归调用栈的深度为 $O(\log n)$。

#### 实际应用

快速排序在实际应用中表现良好，尤其适用于大规模数据的排序。其原地排序特性使其在空间有限的情况下优势明显。然而，为避免最坏情况的发生，常采用随机选择基准元素或三点取中法等改进措施。

#### 总结

快速排序是一种高效的排序算法，其性能在很大程度上取决于分区的平衡性。虽然在最坏情况下时间复杂度为 $O(n^2)$，但在随机输入情况下，其平均时间复杂度为 $O(n \log n)$，适用于大多数实际应用场景。