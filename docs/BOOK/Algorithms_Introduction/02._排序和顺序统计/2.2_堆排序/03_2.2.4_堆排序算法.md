# 03_2.2.4_堆排序算法

"""
Lecture: 02._排序和顺序统计/2.2_堆排序
Content: 03_2.2.4_堆排序算法
"""

### 2.2.4 堆排序算法

堆排序（Heapsort）是一种基于堆（Heap）数据结构的排序算法。堆是一种完全二叉树，分为最大堆和最小堆。在最大堆中，父节点的值总是大于或等于其子节点的值；在最小堆中，父节点的值总是小于或等于其子节点的值。堆排序通过利用堆的这种性质实现高效排序。本文将深入分析堆排序算法的原理、步骤、复杂度以及其具体实现细节。

#### 堆排序算法步骤
堆排序主要包括以下步骤：
1. **构建最大堆**：将无序数组构建成最大堆。最大堆的根节点为数组的最大元素。
2. **排序过程**：
   - 将堆顶元素（即最大元素）与堆的最后一个元素交换位置，这样最大元素就被固定在数组的最后位置。
   - 减少堆的大小，并对新的堆顶元素执行`MAX-HEAPIFY`操作，以维护堆的性质。
   - 重复上述步骤，直到堆的大小减少到1。

伪代码如下：
```
HEAPSORT(A)
1. BUILD-MAX-HEAP(A)
2. for i = A.length downto 2
3.     exchange A[1] with A[i]
4.     A.heap-size = A.heap-size - 1
5.     MAX-HEAPIFY(A, 1)
```
其中，`BUILD-MAX-HEAP`用于构建初始最大堆，`MAX-HEAPIFY`用于维护堆的性质。

#### 关键操作详解
1. **BUILD-MAX-HEAP**：
   该操作通过调用`MAX-HEAPIFY`从最后一个非叶节点开始，自底向上地构建最大堆。时间复杂度为O(n)。

2. **MAX-HEAPIFY**：
   该操作用于维护堆的性质。假设节点`i`的左右子树已经是最大堆，但节点`i`可能违反最大堆性质。通过比较节点`i`与其左右子节点，选择最大的一个与节点`i`交换，并递归调用`MAX-HEAPIFY`直到堆性质恢复。时间复杂度为O(log n)。

3. **交换操作**：
   在堆排序过程中，堆顶元素与最后一个元素交换位置，以逐步将最大元素移至数组末尾。

#### 堆排序的运行时间
堆排序的总运行时间由构建最大堆和排序过程两部分组成：
- 构建最大堆的时间复杂度为O(n)。
- 排序过程需要进行n-1次交换和`MAX-HEAPIFY`操作，每次操作的时间复杂度为O(log n)，因此排序过程的时间复杂度为O(n log n)。

综合来看，堆排序的时间复杂度为O(n log n)，且由于堆排序在原地进行，不需要额外的存储空间，其空间复杂度为O(1)。

#### 堆排序的特点
1. **稳定性**：堆排序是不稳定的排序算法，因为在交换堆顶元素与最后一个元素时，可能改变相同值元素的相对顺序。
2. **适用性**：堆排序适用于大数据量的排序任务，尤其在空间受限的情况下表现优异。
3. **比较次数**：堆排序的比较次数受堆的结构影响，尽管其最坏情况下的比较次数与其他O(n log n)的排序算法相当，但在实际应用中，堆排序的常数因子较小，性能较为稳定。

#### 示例
以下是堆排序的一个具体示例：

初始数组：`A = [4, 10, 3, 5, 1]`
1. 构建最大堆：`[10, 5, 3, 4, 1]`
2. 交换并调整：
   - 交换`10`和`1`：`[1, 5, 3, 4, 10]`
   - 调整：`[5, 4, 3, 1, 10]`
   - 交换`5`和`1`：`[1, 4, 3, 5, 10]`
   - 调整：`[4, 1, 3, 5, 10]`
   - 交换`4`和`1`：`[1, 3, 4, 5, 10]`
   - 调整：`[3, 1, 4, 5, 10]`
   - 交换`3`和`1`：`[1, 3, 4, 5, 10]`
   - 调整：`[3, 1, 4, 5, 10]`
   - 最终排序结果：`[1, 3, 4, 5, 10]`

#### 总结
堆排序通过构建和维护最大堆，实现高效的排序操作。其时间复杂度为O(n log n)，空间复杂度为O(1)，在处理大数据量时表现良好。然而，由于不稳定性和相对较多的交换操作，堆排序在某些情况下可能不如其他高级排序算法（如快速排序）性能优越。