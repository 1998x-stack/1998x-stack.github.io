
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>2.2.1 堆</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>00_2.2.1_堆</h1>
<pre><code>Lecture: 02._排序和顺序统计/2.2_堆排序
Content: 00_2.2.1_堆
</code></pre>
<h3>2.2.1 堆（Heap）</h3>
<p>堆（Heap）是一种特殊的完全二叉树结构，分为最大堆（max-heap）和最小堆（min-heap）。在最大堆中，每个节点的值都不小于其子节点的值，即根节点是堆中的最大元素；而在最小堆中，每个节点的值都不大于其子节点的值，即根节点是堆中的最小元素。</p>
<h4>堆的基本操作</h4>
<p>堆的主要操作包括插入、删除和构建等。以下是一些基本操作的详细解释：</p>
<ol>
<li>
<p><strong>插入操作</strong>：
插入一个新元素时，先将新元素添加到堆的末尾，然后通过向上调整（称为“堆化”）来维持堆的性质。例如，对于最大堆，如果新插入的元素比其父节点大，则交换两者的位置，直到父节点大于等于新插入的元素或达到堆的根节点为止。</p>
</li>
<li>
<p><strong>删除操作</strong>：
删除堆的根节点（最大堆中的最大元素或最小堆中的最小元素）时，将堆的最后一个元素移动到根节点的位置，然后通过向下调整来恢复堆的性质。对于最大堆，如果新的根节点小于其子节点，则与较大的子节点交换位置，直到该节点大于等于其子节点或达到叶节点为止。</p>
</li>
<li>
<p><strong>构建操作</strong>：
从一个无序数组构建堆时，可以通过从最后一个非叶节点开始，逐个对节点进行向下调整（堆化）来完成。这种方法的时间复杂度为O(n)，其中n是数组中的元素个数。</p>
</li>
</ol>
<h4>堆的属性与表示</h4>
<p>堆可以通过数组表示，其中，对于任意节点i，其父节点、左子节点和右子节点的位置分别为：</p>
<ul>
<li>父节点：<code>parent(i) = floor((i-1)/2)</code></li>
<li>左子节点：<code>left(i) = 2*i + 1</code></li>
<li>右子节点：<code>right(i) = 2*i + 2</code></li>
</ul>
<p>这种数组表示法使得堆的操作非常高效，因为可以通过简单的索引计算来访问节点及其子节点。</p>
<h4>最大堆的性质</h4>
<p>最大堆满足以下性质：</p>
<ul>
<li>对于每个节点i，<code>A[parent(i)] ≥ A[i]</code></li>
<li>最大元素存储在根节点，即数组的第一个位置。</li>
</ul>
<h4>堆排序（Heapsort）</h4>
<p>堆排序利用堆这种数据结构来进行排序，其基本步骤如下：</p>
<ol>
<li><strong>构建最大堆</strong>：将无序数组构建成最大堆。</li>
<li><strong>排序</strong>：重复执行以下步骤，直到堆的大小减少到1：
<ul>
<li>交换根节点和堆的最后一个元素，将最大元素固定到数组的末尾。</li>
<li>减少堆的大小，并对新的根节点进行向下调整，以恢复最大堆的性质。</li>
</ul>
</li>
</ol>
<p>堆排序的时间复杂度为O(n log n)，其中n是数组中的元素个数。与归并排序相比，堆排序的空间复杂度为O(1)，因为它在原地进行排序，不需要额外的数组空间。</p>
<h4>应用</h4>
<p>堆不仅在排序中有应用，还广泛用于实现优先队列（Priority Queue）。优先队列是一种抽象数据类型，支持以下操作：</p>
<ul>
<li>插入元素</li>
<li>查找最大（或最小）元素</li>
<li>删除最大（或最小）元素</li>
</ul>
<p>优先队列在算法设计中有着重要的作用，例如在Dijkstra最短路径算法和Huffman编码中。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_2.2.1_堆

"""
Lecture: 02._排序和顺序统计/2.2_堆排序
Content: 00_2.2.1_堆
"""

</code></pre>
  </div>
</body>
</html>
  