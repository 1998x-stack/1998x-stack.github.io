
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>3.3.1 直接地址表</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>00_3.3.1_直接地址表</h1>
<pre><code>Lecture: 03._数据结构/3.3_哈希表
Content: 00_3.3.1_直接地址表
</code></pre>
<h3>3.3.1 直接地址表</h3>
<h4>直接地址表的概念</h4>
<p>直接地址表是一种简单而有效的数据结构，特别适用于当键的集合较小时的情况。设想一个应用需要一个动态集合，其中每个元素都有一个独特的键，这些键来自一个有限的键集合 $U = {0, 1, \ldots, m-1}$，其中 $m$ 不太大。在这种情况下，可以使用一个数组或直接地址表 $T[0 \ldots m-1]$，其中每个位置或槽位对应于宇宙 $U$ 中的一个键 。</p>
<h4>直接地址表的实现</h4>
<p>直接地址表的实现相对简单，每个键 $k$ 直接映射到数组的索引 $T[k]$，如下图所示：</p>
<p><img src="https://example.com/fig11_1.png" alt="Direct-Address Table"></p>
<p>在这个图中，每个键直接对应数组中的一个索引位置。如果集合中不包含键 $k$，则 $T[k] = NIL$ 。</p>
<p>对于直接地址表的操作，主要包括以下几种：</p>
<ol>
<li>
<p><strong>直接地址搜索（DIRECT-ADDRESS-SEARCH）</strong>：从直接地址表中查找键为 $k$ 的元素，时间复杂度为 $O(1)$。</p>
<pre><code class="language-pseudo">DIRECT-ADDRESS-SEARCH(T, k)
    return T[k]
</code></pre>
</li>
<li>
<p><strong>直接地址插入（DIRECT-ADDRESS-INSERT）</strong>：将元素 $x$ 插入到直接地址表中，时间复杂度为 $O(1)$。</p>
<pre><code class="language-pseudo">DIRECT-ADDRESS-INSERT(T, x)
    T[x.key] = x
</code></pre>
</li>
<li>
<p><strong>直接地址删除（DIRECT-ADDRESS-DELETE）</strong>：从直接地址表中删除元素 $x$，时间复杂度为 $O(1)$。</p>
<pre><code class="language-pseudo">DIRECT-ADDRESS-DELETE(T, x)
    T[x.key] = NIL
</code></pre>
</li>
</ol>
<p>这些操作的时间复杂度均为 $O(1)$，非常高效 。</p>
<h4>优缺点分析</h4>
<p>直接地址表的优点在于其操作的时间复杂度非常低，可以在 $O(1)$ 时间内完成插入、删除和查找操作。然而，其主要缺点是空间复杂度较高，当键的集合 $U$ 很大时，直接地址表会占用大量的内存空间。因此，直接地址表适用于键的集合相对较小的情况。</p>
<p>当键的集合 $U$ 非常大或者无限时，存储一个大小为 $|U|$ 的表 $T$ 可能是不切实际的，甚至是不可能的。此外，实际存储的键集合 $K$ 可能相对于 $U$ 来说非常小，这会导致大量的空间浪费  。</p>
<h4>直接地址表的改进</h4>
<p>为了解决直接地址表在空间利用上的缺点，可以考虑使用哈希表。哈希表在键集合相对于宇宙 $U$ 较小时，可以显著减少存储需求，同时保持 $O(1)$ 时间复杂度的查找、插入和删除操作。哈希表通过哈希函数 $h$ 将键映射到数组的索引，从而缩小数组的大小 。</p>
<h4>练习题</h4>
<ul>
<li><strong>练习 11.1-1</strong>：描述一个过程来找到动态集合 $S$ 中的最大元素，该集合用一个长度为 $m$ 的直接地址表 $T$ 表示。分析该过程的最坏情况性能。</li>
<li><strong>练习 11.1-2</strong>：描述如何使用位向量来表示一个动态集合，该集合中的元素来自集合 ${0, 1, \ldots, m-1}$ 并且没有附加数据。字典操作应该在 $O(1)$ 时间内运行。</li>
<li><strong>练习 11.1-3</strong>：提出如何实现一个直接地址表，其中存储元素的键不需要是唯一的，并且元素可以有附加数据。所有三种字典操作（插入、删除和查找）应该在 $O(1)$ 时间内运行。</li>
<li><strong>练习 11.1-4</strong>：描述一种在一个巨大的数组上实现直接地址字典的方法，该数组的大小为 $m$，而字典在任何时间点最多包含 $n$ 个元素。设计要求每个存储对象使用 $O(1)$ 空间；查找、插入和删除操作都应该在 $O(1)$ 时间内完成；数据结构初始化应该在 $O(1)$ 时间内完成。</li>
</ul>
<p>通过这些练习，可以进一步理解和巩固直接地址表的概念及其应用   。</p>
<h3>总结</h3>
<p>直接地址表是一种高效的键值存储结构，适用于键集合较小的情况。其主要优势在于常数时间复杂度的操作性能，但在键集合较大时，会面临严重的空间浪费问题。因此，在实际应用中，需要根据具体情况选择适合的数据结构，例如在键集合较大时，可以考虑使用哈希表来替代直接地址表，以提高空间利用率。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_3.3.1_直接地址表

"""
Lecture: 03._数据结构/3.3_哈希表
Content: 00_3.3.1_直接地址表
"""

</code></pre>
  </div>
</body>
</html>
  