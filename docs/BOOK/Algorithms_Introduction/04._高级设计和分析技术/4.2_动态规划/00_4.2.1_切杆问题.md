# 00_4.2.1_切杆问题

"""
Lecture: 04._高级设计和分析技术/4.2_动态规划
Content: 00_4.2.1_切杆问题
"""

### 4.2.1 切杆问题

#### 背景介绍

切杆问题（Rod Cutting Problem）是动态规划（Dynamic Programming）的经典问题之一。该问题涉及将一根长度为 $n$ 的钢条切割成若干段，使得每段的长度都在给定的价格表中，以最大化销售总收入。这个问题不仅具有重要的理论价值，而且在实际应用中也非常广泛，例如钢铁切割、木材切割等。

#### 问题定义

假设给定长度为 $n$ 的钢条以及长度与价格对应的表格 $p$，即长度为 $i$ 的钢条的价格为 $p[i]$。目标是找到一种切割方案，使得切割后得到的各段钢条的总价格最大。

##### 示例

考虑长度为 4 的钢条，其价格表如下：

| 长度 | 价格 |
|------|------|
| 1    | 1    |
| 2    | 5    |
| 3    | 8    |
| 4    | 9    |

对于长度为 4 的钢条，有多种切割方案，包括但不限于：
1. 不切割，价格为 9。
2. 切割成两段长度为 2 的钢条，价格为 $5 + 5 = 10$。
3. 切割成长度为 1 和 3 的钢条，价格为 $1 + 8 = 9$。

显然，最优解是方案 2，其总价格为 10。

#### 递归解法

最直观的解法是使用递归。我们定义函数 $r(n)$ 表示长度为 $n$ 的钢条的最大收益。递归关系如下：

$$ r(n) = \max_{1 \leq i \leq n} (p[i] + r(n - i)) $$

这种方法的实现如下：
1. 如果钢条长度为 0，最大收益为 0。
2. 初始化最大收益 $q = -\infty$。
3. 对每一种可能的切割长度 $i$，计算当前收益 $p[i] + r(n - i)$ 并更新最大收益 $q$。

虽然递归解法直观，但它存在严重的效率问题。递归过程中会反复计算相同的子问题，导致时间复杂度呈指数级增长。

#### 动态规划解法

为了提高效率，我们采用动态规划方法，通过保存子问题的解来避免重复计算。具体步骤如下：

1. **自顶向下带备忘（Memoization）**：
   - 递归计算每个子问题的解，并将其保存在数组中。
   - 每次计算时，先检查该子问题是否已经计算过，如果是，则直接返回保存的结果。

2. **自底向上（Bottom-Up）**：
   - 按照问题规模从小到大依次计算，逐步构建每个子问题的解。
   - 保存每个子问题的解以供后续计算使用。

这两种方法的时间复杂度均为 $O(n^2)$，显著优于简单递归的指数级复杂度。

##### 自顶向下带备忘的实现步骤

1. 创建一个长度为 $n + 1$ 的数组 $r$，初始时将所有元素置为 $-\infty$，表示尚未计算。
2. 定义递归函数，在计算过程中检查当前问题是否已经解决过，如果是，直接返回保存的结果，否则计算并保存。

##### 自底向上的实现步骤

1. 创建一个长度为 $n + 1$ 的数组 $r$，初始化 $r[0] = 0$。
2. 依次计算 $r[1], r[2], \ldots, r[n]$，每次计算时，遍历所有可能的切割点，并更新最大收益。

#### 具体实现和分析

##### 伪代码

自顶向下带备忘的伪代码：
```
MEMOIZED-CUT-ROD(p, n)
    let r[0..n] be a new array
    for i = 0 to n
        r[i] = -∞
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else
        q = -∞
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n - i, r))
    r[n] = q
    return q
```

自底向上的伪代码：
```
BOTTOM-UP-CUT-ROD(p, n)
    let r[0..n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -∞
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]
```

##### 时间复杂度分析

在这两种动态规划实现中，每个子问题只计算一次，并且每个子问题的计算时间为 $O(n)$。因此，总的时间复杂度为 $O(n^2)$。

#### 结论

切杆问题通过动态规划方法能够有效解决，显著提升计算效率。这种方法的核心在于将大问题分解为子问题，并保存子问题的解以避免重复计算。通过对切杆问题的详细分析，我们不仅理解了动态规划的基本原理，还掌握了如何将其应用于实际问题的技巧。这为解决更复杂的优化问题提供了有力的工具。
