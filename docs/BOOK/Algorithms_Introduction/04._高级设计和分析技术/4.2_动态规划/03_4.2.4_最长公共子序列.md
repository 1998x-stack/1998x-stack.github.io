# 03_4.2.4_最长公共子序列

"""
Lecture: 04._高级设计和分析技术/4.2_动态规划
Content: 03_4.2.4_最长公共子序列
"""

### 4.2.4 最长公共子序列

#### 背景介绍

最长公共子序列（Longest Common Subsequence，简称LCS）是一个经典的动态规划问题，广泛应用于计算机科学中的许多领域，如文件比较、生物信息学中的DNA序列比对等。该问题的目标是在给定两个序列的情况下，找到它们的最长公共子序列。

#### 问题定义

给定两个序列 $X = \langle x_1, x_2, \ldots, x_m \rangle$ 和 $Y = \langle y_1, y_2, \ldots, y_n \rangle$，找到一个最长的子序列，使得该子序列既是 $X$ 的子序列，也是 $Y$ 的子序列。这里，子序列是指从序列中删除一些元素（可以是0个或多个）后得到的序列。

例如，假设 $X = \langle A, B, C, B, D, A, B \rangle$ 和 $Y = \langle B, D, C, A, B, A \rangle$，它们的一个最长公共子序列是 $\langle B, C, B, A \rangle$，长度为4。

#### 动态规划求解方法

动态规划是解决最长公共子序列问题的有效方法。通过构建一个二维表格来保存子问题的解，可以避免重复计算，提高效率。

##### 递归关系

我们定义一个二维数组 $c[i][j]$ 来表示序列 $X[1..i]$ 和 $Y[1..j]$ 的最长公共子序列的长度。则有以下递归关系：

- 如果 $x_i = y_j$，则 $c[i][j] = c[i-1][j-1] + 1$；
- 如果 $x_i \neq y_j$，则 $c[i][j] = \max(c[i-1][j], c[i][j-1])$。

通过这个递归关系，可以构建出一个表格，逐步求解最长公共子序列的长度。

##### 初始化

初始条件是，当 $i = 0$ 或 $j = 0$ 时， $c[i][j] = 0$，因为任何序列与空序列的最长公共子序列长度都是0。

##### 计算过程

通过填充二维数组 $c$，可以得到最终的最长公共子序列的长度。然后，通过回溯方法，可以重建最长公共子序列。

#### 算法步骤

1. **构建二维数组**：
   - 初始化数组 $c$ 和 $b$，其中 $c$ 保存最长公共子序列的长度，$b$ 保存回溯路径。
   
2. **填充数组**：
   - 根据递归关系，从左上角开始填充数组 $c$。
   
3. **回溯重建子序列**：
   - 从右下角开始，根据数组 $b$ 中保存的路径，回溯构建最长公共子序列。

##### 伪代码

```python
def lcs_length(X, Y):
    m = len(X)
    n = len(Y)
    c = [[0] * (n + 1) for _ in range(m + 1)]
    b = [[None] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                c[i][j] = c[i - 1][j - 1] + 1
                b[i][j] = '↖'  # 表示来自左上方
            elif c[i - 1][j] >= c[i][j - 1]:
                c[i][j] = c[i - 1][j]
                b[i][j] = '↑'  # 表示来自上方
            else:
                c[i][j] = c[i][j - 1]
                b[i][j] = '←'  # 表示来自左方
    
    return c, b

def print_lcs(b, X, i, j):
    if i == 0 or j == 0:
        return
    if b[i][j] == '↖':
        print_lcs(b, X, i - 1, j - 1)
        print(X[i - 1], end='')
    elif b[i][j] == '↑':
        print_lcs(b, X, i - 1, j)
    else:
        print_lcs(b, X, i, j - 1)
```

#### 复杂度分析

动态规划方法的时间复杂度为 $O(m \times n)$，空间复杂度也是 $O(m \times n)$。这种方法通过保存子问题的解，避免了指数级别的递归计算，显著提高了效率。

#### 结论

最长公共子序列问题通过动态规划方法能够高效解决。这种方法不仅在理论上有重要意义，而且在实际应用中也展现了其强大的解决问题的能力。通过理解和掌握这种方法，可以解决许多涉及序列比对的复杂问题。

以上是对《算法导论》中4.2.4节最长公共子序列问题的详细解析。希望这些内容对理解动态规划的应用和实现有所帮助。