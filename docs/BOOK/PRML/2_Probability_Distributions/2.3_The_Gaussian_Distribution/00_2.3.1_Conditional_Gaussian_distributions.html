
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>2.3.1 Conditional Gaussian distributions</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h3>2.3.1 条件高斯分布的极其详细分析</h3>
<h4>引言</h4>
<p>条件高斯分布是多变量高斯分布的重要性质之一。如果两个变量集合是联合高斯分布的，那么其中一个变量集合在给定另一个变量集合的条件下，其条件分布仍然是高斯分布。同样地，任意一个变量集合的边缘分布也是高斯分布。</p>
<h4>数学描述</h4>
<p>设 $ \mathbf{x} $ 是一个 $ D $ 维的向量，其服从高斯分布 $ \mathcal{N}(\mathbf{x}|\mathbf{\mu}, \mathbf{\Sigma}) $。我们将 $ \mathbf{x} $ 分成两个不相交的子集 $ \mathbf{x}_a $ 和 $ \mathbf{x}_b $，假设 $ \mathbf{x}_a $ 由 $ \mathbf{x} $ 的前 $ M $ 个分量组成，而 $ \mathbf{x}_b $ 由其余的 $ D-M $ 个分量组成。</p>
<ol>
<li>
<p><strong>定义变量</strong>：
$$
\mathbf{x} = \begin{pmatrix} \mathbf{x}<em bb="">a \ \mathbf{x}<em ba="">b \end{pmatrix}
$$
均值向量：
$$
\mathbf{\mu} = \begin{pmatrix} \mathbf{\mu}<em ab="">a \ \mathbf{\mu}<em aa="">b \end{pmatrix}
$$
协方差矩阵：
$$
\mathbf{\Sigma} = \begin{pmatrix} \mathbf{\Sigma}</em> &amp; \mathbf{\Sigma}</em> \ \mathbf{\Sigma}</em> &amp; \mathbf{\Sigma}</em> \end{pmatrix}
$$</p>
</li>
<li>
<p><strong>协方差矩阵的对称性</strong>：
$$
\mathbf{\Sigma}^T = \mathbf{\Sigma}
$$
因此，$\mathbf{\Sigma}<em bb="">{aa}$ 和 $\mathbf{\Sigma}</em>$ 是对称的，而 $\mathbf{\Sigma}<em ab="">{ba} = \mathbf{\Sigma}</em>^T$。</p>
</li>
<li>
<p><strong>精度矩阵（逆协方差矩阵）</strong>：
定义精度矩阵：
$$
\mathbf{\Lambda} \equiv \mathbf{\Sigma}^{-1}
$$
其分块形式为：
$$
\mathbf{\Lambda} = \begin{pmatrix} \mathbf{\Lambda}<em ab="">{aa} &amp; \mathbf{\Lambda}</em> \ \mathbf{\Lambda}<em bb="">{ba} &amp; \mathbf{\Lambda}</em> \end{pmatrix}
$$</p>
</li>
</ol>
<h4>条件分布的推导</h4>
<p>利用概率的乘法法则，条件分布 $ p(\mathbf{x}_a|\mathbf{x}_b) $ 可以通过联合分布 $ p(\mathbf{x}) = p(\mathbf{x}_a, \mathbf{x}_b) $ 固定 $ \mathbf{x}_b $ 并归一化得到。在不进行显式归一化的情况下，可以通过考虑高斯分布指数项中的二次型形式并在计算结束时重新引入归一化系数来得到解。</p>
<ol>
<li>
<p><strong>高斯分布指数项的二次型形式</strong>：
$$
-\frac{1}{2} (\mathbf{x} - \mathbf{\mu})^T \mathbf{\Sigma}^{-1} (\mathbf{x} - \mathbf{\mu})
$$
根据分块矩阵的形式：
$$
-\frac{1}{2} (\mathbf{x}_a - \mathbf{\mu}<em aa="">a)^T \mathbf{\Lambda}</em> (\mathbf{x}_a - \mathbf{\mu}_a) - \frac{1}{2} (\mathbf{x}_a - \mathbf{\mu}<em ab="">a)^T \mathbf{\Lambda}</em> (\mathbf{x}_b - \mathbf{\mu}_b) - \frac{1}{2} (\mathbf{x}_b - \mathbf{\mu}<em ba="">b)^T \mathbf{\Lambda}</em> (\mathbf{x}_a - \mathbf{\mu}_a) - \frac{1}{2} (\mathbf{x}_b - \mathbf{\mu}<em bb="">b)^T \mathbf{\Lambda}</em> (\mathbf{x}_b - \mathbf{\mu}_b)
$$</p>
</li>
<li>
<p><strong>条件分布的均值和协方差</strong>：
通过对上述表达式中的 $ \mathbf{x}<em ab="">a $ 进行求导，可以得到条件分布的均值和协方差：
$$
p(\mathbf{x}<em a|b="">a|\mathbf{x}<em a|b="">b) = \mathcal{N}(\mathbf{x}<em a|b="">a|\mathbf{\mu}</em>, \mathbf{\Sigma}</em>)
$$
其中：
$$
\mathbf{\mu}</em> = \mathbf{\mu}<em aa="">a - \mathbf{\Lambda}</em>^{-1} \mathbf{\Lambda}</em> (\mathbf{x}<em aa="">b - \mathbf{\mu}<em a|b="">b)
$$
$$
\mathbf{\Sigma}</em> = \mathbf{\Lambda}</em>^{-1}
$$</p>
</li>
</ol>
<h4>总结</h4>
<p>条件高斯分布的重要性在于，它允许我们在已知部分变量的情况下对剩余变量进行推断和分析。这一性质在许多统计模型和机器学习算法中有广泛的应用，如高斯过程、卡尔曼滤波和隐马尔可夫模型等。通过对联合分布和精度矩阵的分析，我们可以有效地推导出条件分布的均值和协方差，从而实现对复杂数据结构的建模和预测。</p>

    <h3>Python 文件</h3>
    <pre><code># 00_2.3.1_Conditional_Gaussian_distributions

"""
Lecture: 2_Probability_Distributions/2.3_The_Gaussian_Distribution
Content: 00_2.3.1_Conditional_Gaussian_distributions
"""

import numpy as np
from scipy.stats import multivariate_normal
from typing import Tuple

class ConditionalGaussian:
    def __init__(self, mu: np.ndarray, sigma: np.ndarray):
        """
        初始化条件高斯分布类
        
        参数:
        mu (np.ndarray): 均值向量
        sigma (np.ndarray): 协方差矩阵
        """
        self.mu = mu
        self.sigma = sigma
        self._check_validity()
    
    def _check_validity(self):
        """检查均值向量和协方差矩阵的有效性"""
        assert self.mu.ndim == 1, "均值向量应为一维"
        assert self.sigma.ndim == 2, "协方差矩阵应为二维"
        assert self.sigma.shape[0] == self.sigma.shape[1], "协方差矩阵应为方阵"
        assert self.mu.shape[0] == self.sigma.shape[0], "均值向量和协方差矩阵的维度应匹配"
    
    def conditional_distribution(self, indices_a: np.ndarray, indices_b: np.ndarray, x_b: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        计算条件高斯分布的均值和协方差矩阵
        
        参数:
        indices_a (np.ndarray): 子集A的索引
        indices_b (np.ndarray): 子集B的索引
        x_b (np.ndarray): 给定的子集B的值
        
        返回:
        Tuple[np.ndarray, np.ndarray]: 条件高斯分布的均值和协方差矩阵
        """
        mu_a = self.mu[indices_a]
        mu_b = self.mu[indices_b]
        sigma_aa = self.sigma[np.ix_(indices_a, indices_a)]
        sigma_ab = self.sigma[np.ix_(indices_a, indices_b)]
        sigma_bb = self.sigma[np.ix_(indices_b, indices_b)]
        sigma_ba = self.sigma[np.ix_(indices_b, indices_a)]

        sigma_bb_inv = np.linalg.inv(sigma_bb)
        mu_cond = mu_a + sigma_ab @ sigma_bb_inv @ (x_b - mu_b)
        sigma_cond = sigma_aa - sigma_ab @ sigma_bb_inv @ sigma_ba

        return mu_cond, sigma_cond
    
    def sample_conditional(self, indices_a: np.ndarray, indices_b: np.ndarray, x_b: np.ndarray, size: int = 1) -> np.ndarray:
        """
        从条件高斯分布中采样
        
        参数:
        indices_a (np.ndarray): 子集A的索引
        indices_b (np.ndarray): 子集B的索引
        x_b (np.ndarray): 给定的子集B的值
        size (int): 采样数量
        
        返回:
        np.ndarray: 采样结果
        """
        mu_cond, sigma_cond = self.conditional_distribution(indices_a, indices_b, x_b)
        samples = multivariate_normal.rvs(mean=mu_cond, cov=sigma_cond, size=size)
        return samples

# 示例用法
if __name__ == "__main__":
    mu = np.array([1.0, 2.0, 3.0, 4.0])
    sigma = np.array([
        [1.0, 0.5, 0.3, 0.2],
        [0.5, 1.0, 0.4, 0.3],
        [0.3, 0.4, 1.0, 0.6],
        [0.2, 0.3, 0.6, 1.0]
    ])
    
    cg = ConditionalGaussian(mu, sigma)
    indices_a = np.array([0, 1])
    indices_b = np.array([2, 3])
    x_b = np.array([2.5, 3.5])
    
    mu_cond, sigma_cond = cg.conditional_distribution(indices_a, indices_b, x_b)
    print("条件均值:", mu_cond)
    print("条件协方差矩阵:", sigma_cond)
    
    samples = cg.sample_conditional(indices_a, indices_b, x_b, size=5)
    print("条件采样结果:", samples)</code></pre>
  </div>
</body>
</html>
  