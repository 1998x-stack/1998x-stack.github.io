
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <title>4.7 自回归移动平均过程的和</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap">
  <link rel="stylesheet" href="../markdown.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../markdown.js"></script>
</head>
<body>
  <div class="container">
    <h1>06_4.7 自回归移动平均过程的和</h1>
<pre><code>Lecture: /第4章 预测
Content: 06_4.7 自回归移动平均过程的和
</code></pre>
<h3>第4章 预测</h3>
<h4>4.7 自回归移动平均过程的和</h4>
<p>本节详细探讨了自回归移动平均（ARMA）过程的和。ARMA模型在时间序列分析中具有重要的地位，广泛应用于经济、金融等领域的时间序列预测。以下是对本节内容的详细分析。</p>
<hr>
<h4>1. ARMA过程的定义与性质</h4>
<p><strong>自回归移动平均过程（ARMA）</strong></p>
<ul>
<li><strong>定义</strong>：ARMA过程结合了自回归（AR）过程和移动平均（MA）过程的特性。一个ARMA(p,q)过程定义为：</li>
</ul>
<p>$$ X_t = \phi_1 X_{t-1} + \phi_2 X_{t-2} + \cdots + \phi_p X_{t-p} + \epsilon_t + \theta_1 \epsilon_{t-1} + \theta_2 \epsilon_{t-2} + \cdots + \theta_q \epsilon_{t-q} $$</p>
<p>其中，$ \phi_i $ 是自回归系数，$ \theta_j $ 是移动平均系数，$ \epsilon_t $ 是白噪声。</p>
<ul>
<li><strong>性质</strong>：ARMA过程具有以下几个重要性质：
<ul>
<li><strong>平稳性</strong>：在适当条件下（如所有特征根在单位圆之外），ARMA过程是平稳的。</li>
<li><strong>可逆性</strong>：在适当条件下（如所有特征根在单位圆之内），ARMA过程是可逆的。</li>
<li><strong>自相关函数（ACF）和偏自相关函数（PACF）</strong>：ARMA过程的ACF和PACF具有特定的衰减模式，这有助于模型的识别和参数估计。</li>
</ul>
</li>
</ul>
<hr>
<h4>2. ARMA过程的识别</h4>
<p><strong>模型识别</strong></p>
<ul>
<li>
<p><strong>自相关函数和偏自相关函数</strong>：通过分析时间序列的ACF和PACF，可以初步确定ARMA模型的阶数。具体步骤如下：</p>
<ol>
<li><strong>绘制ACF和PACF图</strong>：观察ACF和PACF的截尾和拖尾特性。</li>
<li><strong>确定模型阶数</strong>：根据ACF和PACF的模式，确定AR(p)模型的阶数p和MA(q)模型的阶数q。</li>
</ol>
</li>
<li>
<p><strong>信息准则</strong>：使用AIC（Akaike信息准则）、BIC（贝叶斯信息准则）等信息准则，选择最优的模型阶数。</p>
</li>
</ul>
<hr>
<h4>3. ARMA过程的参数估计</h4>
<p><strong>参数估计方法</strong></p>
<ul>
<li>
<p><strong>Yule-Walker方程</strong>：用于估计AR模型的参数，通过解线性方程组得到。</p>
</li>
<li>
<p><strong>最大似然估计（MLE）</strong>：用于估计ARMA模型的参数，通过最大化似然函数得到。具体步骤包括：</p>
<ol>
<li><strong>构建似然函数</strong>：根据时间序列的观测值构建似然函数。</li>
<li><strong>求解最优参数</strong>：通过数值优化方法，最大化似然函数，得到参数估计值。</li>
</ol>
</li>
<li>
<p><strong>最小二乘法</strong>：用于估计MA模型的参数，通过最小化预测误差平方和得到。</p>
</li>
</ul>
<hr>
<h4>4. ARMA过程的预测</h4>
<p><strong>一步预测和多步预测</strong></p>
<ul>
<li><strong>一步预测</strong>：利用当前和过去的观测值，预测下一时刻的值。预测公式为：</li>
</ul>
<p>$$ \hat{X}<em t-1="">{t+1|t} = \phi_1 X_t + \phi_2 X</em> + \cdots + \phi_p X_{t-p+1} + \theta_1 \epsilon_t + \theta_2 \epsilon_{t-1} + \cdots + \theta_q \epsilon_{t-q+1} $$</p>
<ul>
<li><strong>多步预测</strong>：利用递归方法，逐步预测未来多个时刻的值。具体步骤如下：
<ol>
<li><strong>初始化</strong>：利用当前和过去的观测值进行一步预测。</li>
<li><strong>递归预测</strong>：将预测值作为已知值，继续进行下一步预测，直到得到所需的多步预测值。</li>
</ol>
</li>
</ul>
<hr>
<h4>5. 应用示例</h4>
<p><strong>金融时间序列预测</strong></p>
<ul>
<li>
<p><strong>背景</strong>：金融时间序列数据（如股票价格、汇率）通常具有较强的随机性和波动性，适合使用ARMA模型进行建模和预测。</p>
</li>
<li>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>数据预处理</strong>：对原始数据进行差分、对数变换等预处理，以使其平稳。</li>
<li><strong>模型识别</strong>：通过绘制ACF和PACF图，初步确定模型阶数。</li>
<li><strong>参数估计</strong>：使用最大似然估计方法，估计模型参数。</li>
<li><strong>模型检验</strong>：通过残差分析和信息准则，检验模型的拟合效果。</li>
<li><strong>进行预测</strong>：利用训练好的ARMA模型，对未来的时间点进行预测，并评估预测效果。</li>
</ol>
</li>
</ul>
<hr>
<h4>6. 结论</h4>
<p>ARMA过程的和提供了一种结合自回归和移动平均特性的强大工具，用于时间序列建模和预测。通过合理选择模型阶数、精确估计参数，并进行充分的模型检验，可以有效地进行时间序列预测。在实际应用中，ARMA模型在金融、经济等领域具有广泛的应用前景。</p>

    <h3>Python 文件</h3>
    <pre><code># 06_4.7 自回归移动平均过程的和

"""
Lecture: /第4章 预测
Content: 06_4.7 自回归移动平均过程的和
"""

import numpy as np
from typing import Tuple

class ARMAModel:
    """自回归移动平均（ARMA）模型

    该类实现了 ARMA(p, q) 模型的参数估计和预测功能。

    Attributes:
        p (int): 自回归（AR）项的阶数。
        q (int): 移动平均（MA）项的阶数。
        ar_params (np.ndarray): 自回归参数。
        ma_params (np.ndarray): 移动平均参数。
        residuals (np.ndarray): 残差。
    """
    
    def __init__(self, p: int, q: int):
        """
        初始化 ARMA 模型。

        Args:
            p (int): 自回归（AR）项的阶数。
            q (int): 移动平均（MA）项的阶数。
        """
        self.p = p
        self.q = q
        self.ar_params = None
        self.ma_params = None
        self.residuals = None
    
    def fit(self, time_series: np.ndarray):
        """
        估计 ARMA 模型的参数。

        Args:
            time_series (np.ndarray): 时间序列数据，形状为 (n_samples,)。
        """
        # 初始估计参数
        self.ar_params = np.random.randn(self.p)
        self.ma_params = np.random.randn(self.q)
        
        # 计算残差
        self.residuals = np.zeros_like(time_series)
        for t in range(max(self.p, self.q), len(time_series)):
            ar_term = np.dot(self.ar_params, time_series[t-self.p:t][::-1])
            ma_term = np.dot(self.ma_params, self.residuals[t-self.q:t][::-1])
            self.residuals[t] = time_series[t] - ar_term - ma_term
        
        # 最小化残差平方和，估计参数
        def objective(params):
            self.ar_params = params[:self.p]
            self.ma_params = params[self.p:]
            residuals = np.zeros_like(time_series)
            for t in range(max(self.p, self.q), len(time_series)):
                ar_term = np.dot(self.ar_params, time_series[t-self.p:t][::-1])
                ma_term = np.dot(self.ma_params, self.residuals[t-self.q:t][::-1])
                residuals[t] = time_series[t] - ar_term - ma_term
            return np.sum(residuals**2)
        
        from scipy.optimize import minimize
        initial_params = np.concatenate([self.ar_params, self.ma_params])
        result = minimize(objective, initial_params, method='L-BFGS-B')
        self.ar_params = result.x[:self.p]
        self.ma_params = result.x[self.p:]
    
    def predict(self, steps: int) -> np.ndarray:
        """
        预测未来的时间序列值。

        Args:
            steps (int): 预测的步数。
        
        Returns:
            np.ndarray: 预测值，形状为 (steps,)。
        """
        predictions = np.zeros(steps)
        for t in range(steps):
            if t < self.p:
                ar_term = np.dot(self.ar_params[:t], predictions[:t][::-1])
            else:
                ar_term = np.dot(self.ar_params, predictions[t-self.p:t][::-1])
            
            if t < self.q:
                ma_term = np.dot(self.ma_params[:t], self.residuals[:t][::-1])
            else:
                ma_term = np.dot(self.ma_params, self.residuals[t-self.q:t][::-1])
            
            predictions[t] = ar_term + ma_term
        
        return predictions

# 主程序
if __name__ == "__main__":
    # 示例时间序列数据
    time_series = np.array([1.0, 0.9, 1.1, 1.3, 0.8, 0.7, 1.2, 1.5, 0.9, 0.8])
    
    # 创建 ARMA 模型
    p, q = 2, 2
    arma_model = ARMAModel(p, q)
    
    # 拟合模型
    arma_model.fit(time_series)
    
    # 进行预测
    steps = 5
    predictions = arma_model.predict(steps)
    
    # 打印预测结果
    print("预测值:")
    print(predictions)
    
    # 打印估计的参数
    print("估计的 AR 参数:")
    print(arma_model.ar_params)
    
    print("估计的 MA 参数:")
    print(arma_model.ma_params)</code></pre>
  </div>
</body>
</html>
  